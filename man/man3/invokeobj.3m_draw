." Text automatically generated by txt2man
.TH "invokeobj" "3m_draw" "April 17, 2023" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." set smaller margin and spacing options
.ta T 0.2i
.nr IN 0.2i
." -----------------------------------------------------------------
.SH NAME
invokeobj(3f) - [M_draw] invoke object with specified transformations
(LICENSE:PD)

.SH SYNOPSIS
subroutine invokeobj(xt,yt,zt,xs,ys,zs,xr,yr,zr,iobject)
.PP
.nf
.fam C
    real,intent(in)    :: xt,yt,zt
    real,intent(in)    :: xs,ys,zs
    real,intent(in)    :: xr,yr,zr
    integer,intent(in) :: iobject

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
save and restore the coordinate system while invoking an object with
specified translation, rotation, and scaling.
.SH OPTIONS
.TP
.B xt,yt,zt
linear transforms
.TP
.B xs,ys,zs
scaling
.TP
.B xr,yr,zr
rotation in degrees
.TP
.B iobject
object to invoke
.SH EXAMPLE
Sample program
.PP
.nf
.fam C
   program demo_invokeobj
   use M_draw
   implicit none
   real :: a, angle, step
   integer :: i, idum
   ! set window size
      call prefsize(700,700)
      call prefposition( 0, 0)
      call vinit ('X11')
      a=1.0
   ! make an object to draw ( a disk with an arrow on it)
      call makeobj(12345)
      call polyfill(.TRUE.)
      call color( 5)
      call circle( 0.0, 0.0, a)
      call color( 3)
      call makepoly()
      call move2( 0.00*a, 0.80*a)
      call draw2( 0.50*a, 0.30*a)
      call draw2( 0.20*a, 0.30*a)
      call draw2( 0.20*a,-0.80*a)
      call draw2(-0.20*a,-0.80*a)
      call draw2(-0.20*a, 0.30*a)
      call draw2(-0.50*a, 0.30*a)
      call draw2( 0.00*a, 0.80*a)
      call closepoly()
      call polyfill(.FALSE.)
      call color(7)
      call linewidth(20)
      call circleprecision(200)
      call circle( 0.0, 0.0, a)
      call vflush()
      call closeobj()
   ! draw the disk invoking different rotation
      ANGLE=0.0
      STEP=0.4
      idum=backbuffer()
      idum=-1
      if(idum.ne.-1)then
         do i=1,int(360/STEP*10)
            idum=backbuffer()
            call clear()
            call invokeobj( 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, ANGLE, ANGLE, ANGLE,12345)
            ANGLE=ANGLE+STEP
            call swapbuffers()
         enddo
      else
         ANGLE=45.0
         call invokeobj( 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, ANGLE, ANGLE, ANGLE,12345)
         idum=getkey()
      endif
      call vexit()
   end program demo_invokeobj
.fam T
.fi
.SH AUTHOR
John S. Urban
.SH LICENSE
Public Domain
