<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="github-markdown.css">
<style>
@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

.markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
</style>
<style>
 .markdown-body {
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 0 auto;
  padding: 45px;
 }

 @media (max-width: 767px) {
  .markdown-body {
   padding: 15px;
  }
 }
</style>
</head>
<body>
<article class="markdown-body">
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c1">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>M_draw(3fm)</b> - [M_draw::INTRO] The M_draw graphics library <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">DESCRIPTION</a></h3>
      <blockquote>
        <p>M_draw is a portable public-domain device-independent graphics library intended for being called from Fortran that is based on VOGLE (from the
        The University of Melbourne) that is loosely based on the Silicon Graphics Iris GL library. It was also partly inspired by the DIGS library
        developed at the U.S. Naval Academy under the guidance of Prof David Rogers.</p>
        <p>Many output devices are available:</p>
        <blockquote>
          <table cellpadding="3">
            <!-- tsb: Many output devices are available:
 -->
            <tr valign="top">
              <td width="3%">o</td>
              <td>FrameMaker MIF 3.0 (Maker Interchange File) driver.</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>Adobe PDF driver.</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>HTML5 Canvas driver.</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>SVG driver.</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>A PCL5/HPGL2 driver that supports <b>prefsize</b>() calls.</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>Monochrome PBM (Poskanzer bitmap P1 and P4 formats) and X11 bitmap driver.</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>Color PBM (Poskanzer pixmap P3 and P6 formats). If you have the pbmplus package you can use it to make M_draw appear to write any format
              pbmplus writes (assuming your system supports the <b>popen</b>(3c) function).</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>A clear-text CGM (Computer Graphics Metafile) driver.</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>A different (color) PostScript driver.</td>
            </tr>
            <tr valign="top">
              <td width="3%">o</td>
              <td>A driver for Microsoft VML (Vector Markup Language)</td>
            </tr>
          </table>
        </blockquote>
        <p>M_draw is intended to produce simple graphics composed of line drawings and polygon fills in two and three dimensions. It handles circles,
        curves, arcs, patches, polygons, and software text in a device independent fashion. Simple hidden line removal is also available via polygon
        backfacing. Access to hardware text and double buffering of drawings depends on the driver.</p>
        <p>M_draw is is callable from C and Fortran; but M_draw is only supported in Fortran (the C components are being
        converted to Fortran).</p>
        <p>The original VOGLE source's ownership statement</p>
        <pre>
      This software is public domain and may be used for any purpose commercial
      or otherwise. It is offered without any guarantee as to its suitability
      for any purpose or as to the sanity of its writers. The authors do ask
      that the source is passed on to anyone that requests a copy, and that
      people who get copies don't go round claiming they wrote it. Use at your
      own risk.
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">LIBRARY FUNCTION DESCRIPTIONS</a></h3><a name=""></a>
      <h4><a name="">DEVICE ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>vinit</b>(device)</td>
            <td>Initialise device</td>
          </tr>
          <tr valign="top">
            <td width="6%" nowrap="nowrap"><b>vexit</b>()</td>
            <td valign="bottom">Reset window/terminal (must be last routine called)</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>voutput</b>(path)</td>
            <td>Redirect output from *next* vinit to file</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>vnewdev</b>(device)</td>
            <td>Reinitialize to use new device without changing</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>vgetdev</b>(device)</td>
            <td>Get name of current device</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>pushdev</b>(device)</td>
            <td>push current device onto a stack</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>popdev</b>(device)</td>
            <td>pop device from stack created by pushdev.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getdepth</b>()</td>
            <td>Return number of bit planes (color planes)</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">ROUTINES FOR SETTING UP WINDOWS</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>prefposition</b>(x, y)</td>
            <td>Specify preferred position of window</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>prefsize</b>(width, height)</td>
            <td>Specify preferred width and height of window</td>
          </tr>
        </table>Some devices are basically window oriented - like sunview and X11. You can give M_draw some information on the window that it will use with
        these routines. These can make your code very device independent. Both routines take arguments which are in device space. (0, 0) is the top left
        hand corner in device space. To have any effect these routines must be called before vinit. For the X11 device, an entry may be made in your
        .Xdefaults file or loaded in with the <b>xrdb</b>(1) command:
        <pre>
      xrdb &lt;&lt;\end_of_file
      ! X11 Windows fonts to use for "small" and "large" fonts
      M_draw*smallfont: fixed
      M_draw*largefont: 9x15
      ! title on decoration bar for the window
      M_draw*title: My M_draw program
      ! window geometry and position,
      ! overridden by prefsize(3c) and prefposition(3c)
      M_draw.Geometry: =500x500-10+20
      end_of_file
<br />
</pre>(where you specify your geometry as you please).
      </blockquote><a name=""></a>
      <h4><a name="">CLIPPING ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>clipping</b>(onoff)</td>
            <td>Turn clipping on or off</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">COLOR ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td width="6%" nowrap="nowrap"><b>clear</b>()</td>
            <td valign="bottom">Clears screen to current color</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>color</b>(col)</td>
            <td>Set current color <b>mapcolor</b>(indx, red, green, blue) Set color map index</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">INTERACTIVE ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>getkey</b>()</td>
            <td>Return ASCII ordinal of next key typed</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>checkkey</b>()</td>
            <td>Returns zero if no key is pressed or ASCII ordinal</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getstring</b>(bcol, string)</td>
            <td>Read in a string, echoing it in current font</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>locator</b>(xaddr, yaddr)</td>
            <td>Find out where cursor is</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>slocator</b>(xaddr, yaddr)</td>
            <td>Find out where cursor is in screen coordinates</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">FLUSHING</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>vsetflush</b>(yesno)</td>
            <td>Set global flushing status</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>vflush</b>()</td>
            <td>Call device flush or syncronisation routine</td>
          </tr>
          <tr>
            <td colspan="2">On some devices (particularly X11) considerable speedups in display can be achieved by not flushing each graphics primitive call
            to the actual display until necessary. M_draw automatically delays flushing in the following cases:</td>
          </tr>
          <tr>
            <td width="6%"></td>
            <td>
              <table width="100%" cellpadding="3">
                <tr valign="top">
                  <td width="3%">o</td>
                  <td>Within a <b>callobj</b>() call.</td>
                </tr>
                <tr valign="top">
                  <td width="3%">o</td>
                  <td>Within curves and patches.</td>
                </tr>
                <tr valign="top">
                  <td width="3%">o</td>
                  <td>Within Hershey software text.</td>
                </tr>
                <tr valign="top">
                  <td width="3%">o</td>
                  <td>When double buffering (the flush is only done within swapbuffers).</td>
                </tr>
              </table><!-- .PP -->
            </td>
          </tr>
        </table>There are two user routines that can be used to control flushing.
      </blockquote><a name=""></a>
      <h4><a name="">VIEWPORT ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>viewport</b>(left, right, bottom, top)</td>
            <td>Specify which part of screen to draw in</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>pushviewport</b>()</td>
            <td>Save current viewport</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>popviewport</b>()</td>
            <td>Retrieve last viewport</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getviewport</b>(left, right, bottom,top)</td>
            <td>Returns limits of current viewport in screen coordinates</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>expandviewport</b>()</td>
            <td>use the entire device viewport</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>unexpandviewport</b>()</td>
            <td>undo <b>expandviewport</b>(3f)</td>
          </tr>
        </table>
      </blockquote>
      <blockquote>
        Viewpoint routines alter the current transformation matrix.
      </blockquote><a name=""></a>
      <h4><a name="">GETTING THE ASPECT DETAILS</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>getaspect</b>()</td>
            <td>Returns the ratio height over width of the display device.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getfactors</b>(wfact, hfact)</td>
            <td>Returns width over <b>min</b>(width of device, height of device) and height over <b>min</b>(width of device, height of device).</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getdisplaysize</b>(w, h)</td>
            <td>Returns width and height of device in device units</td>
          </tr>
        </table>
      </blockquote>
      <blockquote>
        Often the screen is not perfectly square and it would be nice to use the extra space without having to turn clipping off. The following routines are
        provided to get the values needed to adjust the calls to viewport, etc as needed.
      </blockquote><a name=""></a>
      <h4><a name="">ATTRIBUTE STACK ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>pushattributes</b>()</td>
            <td>Save the current attributes on the attribute stack.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>popattributes</b>()</td>
            <td>Restore attributes to what they were at last <b>pushattributes</b>().</td>
          </tr>
        </table>
      </blockquote>
      <blockquote>
        The attribute stack contains details such as current color, filling, hatching, centered, fixedwidth, text height, text width, and the current font.
        If you need to prevent object calls from changing these, use pushattributes before the call and popattributes after.
      </blockquote><a name=""></a>
      <h4><a name="">PROJECTION ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>ortho</b>(left, right, bottom, top,near,far)</td>
            <td>Define x,y,z clipping planes.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>ortho2</b>(left, right, bottom, top)</td>
            <td>Define x and y clipping planes.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>perspective</b>(fov, aspect, near, far)</td>
            <td>Specify perspective viewing pyramid</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>window</b>(left, right, bot, top, near,far)</td>
            <td>Specify a perspective viewing pyramid</td>
          </tr>
        </table>
      </blockquote>
      <blockquote>
        All the projection routines define a new transformation matrix, and consequently the world units. Parallel projections are defined by ortho or
        ortho2. Perspective projections can be defined by perspective and window.
      </blockquote><a name=""></a>
      <h4><a name="">MATRIX STACK ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>pushmatrix</b>()</td>
            <td>Save the current transformation matrix on the matrix stack.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>popmatrix</b>()</td>
            <td>Reinstall the last matrix pushed</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">VIEWPOINT ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>polarview</b>(dist, azim, inc, twist)</td>
            <td>Specify the viewer's position in polar coordinates</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>up</b>(x, y, z)</td>
            <td>Specify the world up.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>lookat</b>(vx, vy, vz, px, py, pz,twist)</td>
            <td>Specify the viewer's position</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">MOVE ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>move</b>(x, y, z)</td>
            <td>Move current graphics position to (x, y, z)</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rmove</b>(deltax, deltay, deltaz)</td>
            <td>Relative move</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>move2</b>(x, y)</td>
            <td>Move graphics position to point (x, y)</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rmove2</b>(deltax, deltay)</td>
            <td>Relative move in world units.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>smove2</b>(x, y)</td>
            <td>Move current graphics position in screen coordinates (<b>-1.0</b> to 1.0).</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rsmove2</b>(deltax, deltay)</td>
            <td>Relative move in screen units (<b>-1.0</b> to 1.0).</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">LINESTYLE ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>linewidth</b>()</td>
            <td>set line width in rasters</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>dashcode</b>()</td>
            <td>set dash pattern length</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>linestyle</b>()</td>
            <td>set the line dash pattern</td>
          </tr>
        </table>Linestyles are specified by giving a nominal length of a single dash and a character string consisting of 1's and 0's (zeros) that specify
        when to draw a dash and when not to draw a dash. Linestyles will follow curves and "go around" corners. If a linestyle is set or reset, the
        accumulated information as to where on a curve (or line) a dash is to be draw is also reset.
        <p>For EXAMPLE, with a nominal view of <b>-1</b> to 1, setting the dash length to 0.5, and the linestyle to '11010' would draw a <b>line</b>(or
        curve) with a 1.0 unit solid part, followed by a 0.5 unit blank part followed by a 0.5 unit solid part followed by a 0.5 unit blank part. The
        linestyle would then repeat itself.</p>
        <p>The dash sizes are affected by the current viewport/transformation scaling factors, meaning that in perspective, the dashes look smaller the
        farther away they are.</p>
      </blockquote><a name=""></a>
      <h4><a name="">DRAW ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>draw</b>(x, y, z)</td>
            <td>Draw from current graphics position to (x, y, z)</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rdraw</b>(deltax, deltay, deltaz)</td>
            <td>Relative draw</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>draw2</b>(x, y)</td>
            <td>Draw from current graphics position to point (x, y)</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rdraw2</b>(deltax,deltay)</td>
            <td>Relative draw</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>sdraw2</b>(x, y)</td>
            <td>Draw in screen coordinates (<b>-1.0</b> to 1.0).</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rsdraw2</b>(deltax, deltay)</td>
            <td>Relative draw in screen units (<b>-1.0</b> to 1.0).</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">ARCS AND CIRCLES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>circleprecision</b>(nsegs)</td>
            <td>Set number of line segments in a circle. Default is 32.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>arc</b>(x, y, radius, startang, endang)</td>
            <td>Draw an arc in world units.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>sector</b>(x, y, radius, startang,endang)</td>
            <td>Draw a sector. Note: sectors are polygons.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>circle</b>(x, y, radius)</td>
            <td>Draw a circle. Note: circles are polygons.</td>
          </tr>
        </table>When creating arcs and sectors note that angles are measured in degrees; where <b>zero</b>(0) is the positive X axis in a right-handed
        Cartesian coordinate system and positive angles sweep counterclockwise. If filling sectors or circles (As described in the section on polygons)
        hatch pitch is measured in world coordinates and is initially set to 0.1. The initial hatch angle is <b>zero</b>(0).
      </blockquote><a name=""></a>
      <h4><a name="">CURVE ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>curvebasis</b>(basis)</td>
            <td>Define a basis matrix for a curve.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>curveprecision</b>(nsegs)</td>
            <td>Define number of line segments used to draw a curve.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rcurve</b>(geom)</td>
            <td>Draw a rational curve.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>curve</b>(geom)</td>
            <td>Draw a curve.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>curven</b>(n, geom)</td>
            <td>Draw n - 3 overlapping curve segments. Note: n must be at least 4.</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">RECTANGLES AND GENERAL POLYGON ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>rect</b>(x1, y1, x2, y2)</td>
            <td>Draw a rectangle.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>polyfill</b>(onoff)</td>
            <td>Set the polygon fill flag</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>polyhatch</b>(onoff)</td>
            <td>Set the polygon hatch flag</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>hatchang</b>(angle)</td>
            <td>Set the angle of the hatch lines.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>hatchpitch</b>(pitch)</td>
            <td>Set the distance between hatch lines.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>poly2</b>(n, points)</td>
            <td>Construct an (x, y) polygon from an array of points</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>poly</b>(n, points)</td>
            <td>Construct a polygon from an array of points</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>makepoly</b>()</td>
            <td>opens polygon constructed by a series of move-draws and closed by closepoly</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>closepoly</b>()</td>
            <td>Terminates a polygon opened by makepoly.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>backface</b>(onoff)</td>
            <td>Turns on culling of backfacing polygons.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>backfacedir</b>(clockwise)</td>
            <td>Sets backfacing direction to clockwise or anti-clockwise</td>
          </tr>
          <tr>
            <td colspan="2">A polygon is composed of a number of coplanar line segments connected end to end to form a closed shape.</td>
          </tr>
          <tr>
            <td colspan="2">In M_draw curves are estimated by a series of line segments, and thus may be included easily into polygons.</td>
          </tr>
          <tr valign="top">
            <td class="c2" colspan="1">Regular</td>
            <td>A polygon with all sides and interior angles the same. Regular polygons are always convex. See Regular Polygons</td>
          </tr>
          <tr valign="top">
            <td class="c2" colspan="1">Irregular</td>
            <td>Each side may a different length, each angle may be a different measure. The opposite of a regular polygon. See Irregular Polygons</td>
          </tr>
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">Convex</td>
            <td valign="bottom">All interior angles less than 180 ,and all vertices 'point outwards' away from the interior. The opposite of concave.
            Regular polygons are always convex. See Convex Polygons</td>
          </tr>
          <tr valign="top">
            <td class="c2" colspan="1">Concave</td>
            <td>One or more interior angles greater than 180 . Some vertices push 'inwards' towards the interior of the polygon. The opposite of
            convex.</td>
          </tr>
          <tr valign="top">
            <td class="c2" colspan="1">Self-intersecting or Crossed</td>
            <td>A polygon where one or more sides crosses back over another side, creating multiple smaller polygons. Most of the properties and theorems
            concerning polygons do not apply to this shape. It is best considered as several separate polygons. A polygon that in not self-intersecting in
            this way is called a simple polygon.</td>
          </tr>
        </table>
      </blockquote>
      <p><a name=""></a></p>
      <h4><a name="">TEXT ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>font</b>(fontname)</td>
            <td>set the current font</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>numchars</b>()</td>
            <td>return number of characters in the current SOFTWARE font.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>textsize</b>(width, height)</td>
            <td>set maximum size of a character in the current SOFTWARE font.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>textang</b>(ang)</td>
            <td>set the SOFTWARE text angle.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>fixedwidth</b>(onoff)</td>
            <td>turns fixedwidth mode on or off for SOFTWARE fonts.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getcharsize</b>(c, width, height)</td>
            <td>get the width and height of a character.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getfontdec</b>()</td>
            <td>return size of maximum font descender</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getfontsize</b>(width, height)</td>
            <td>get maximum width and height of a character in a font.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>drawchar</b>(c)</td>
            <td>draw the character c and update current position.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>drawstr</b>(str)</td>
            <td>draw the text in string at the current position.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>strlength</b>(str)</td>
            <td>return the length of the string s</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>boxtext</b>(x, y, l, h, s)</td>
            <td>stretch and draw the SOFTWARE string s so that it fits in the imaginary box</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>boxfit</b>(x, y, l, h, s)</td>
            <td>resize the SOFTWARE text size so it fits in a box</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>textjustify</b>(val)</td>
            <td>general text justification</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>leftjustify</b>()</td>
            <td>left justify text</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rightjustify</b>()</td>
            <td>right justify text</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>topjustify</b>()</td>
            <td>top justify text</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>bottomjustify</b>()</td>
            <td>bottom justify text</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>centertext</b>(onoff)</td>
            <td>turns centertext mode on or off for SOFTWARE fonts.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>xcentertext</b>()</td>
            <td>center text in the X direction</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>ycentertext</b>()</td>
            <td>center text in the Y direction</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>textslant</b>()</td>
            <td>defines the obliqueness of the fonts.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>textweight</b>()</td>
            <td>defines the weight of the fonts.</td>
          </tr>
        </table>M_draw supports hardware and software fonts. The software fonts are based on the character set digitized by Dr Allen V. Hershey while
        working at the U. S. National Bureau of Standards. Exactly what hardware fonts are supported depends on the device, but it is guaranteed that the
        names "large" and "small" will result in something readable. For X11 displays the default large and small fonts used by the program can be
        overridden by placing the following defaults in the ~/.Xdefaults file:
        <pre>
     draw.smallfont: X11-font-name
     draw.largefont: X11-font-name
<br />
</pre>It is noted here that hardware text is always assumed to be drawn parallel to the (x, y) plane, using whatever the current z coordinate is. The
following software fonts are supported:
        <pre>
      astrology       cursive         cyrillic        futura.l
      futura.m        gothic.eng      gothic.ger      gothic.ita
      greek           markers         math.low        math.upp
      meteorology     music           script          symbolic
      times.g         times.i         times.ib        times.r
      times.rb        japanese
<br />
</pre>A markers font "markers" is also provided for doing markers - you need to have centertext mode on for this to give sensible results when placing the
markers.
        <p>If the environment variable "M_DRAW_FONTPATH" is set M_draw looks for the software fonts in the directory given by this value.</p>
        <p>the default font is futura.l</p>
      </blockquote><a name=""></a>
      <h4><a name="">TRANSFORMATION ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>translate</b>(x, y, z)</td>
            <td>Set up a translation.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>scale</b>(x, y, z)</td>
            <td>Set up scaling factors in x, y, and z axis.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rotate</b>(angle, axis)</td>
            <td>Set up a rotation in axis axis where axis is one of 'x','y', or 'z'.</td>
          </tr>
        </table>All transformations are cumulative, so if you rotate something and then do a translate you are translating relative to the rotated axes. If
        you need to preserve the current transformation matrix use <b>pushmatrix</b>(), do the drawing, and then call <b>popmatrix</b>() to get back where
        you were before.
        <p>When doing transformations, ensure your objects remain in the viewing volume or they will be clipped. See routines such as <b>ortho</b>(3) for
        more information.</p>
      </blockquote><a name=""></a>
      <h4><a name="">PATCH ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>patchbasis</b>(tbasis, ubasis)</td>
            <td>Define the t and u basis matrices of a patch.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>patchprecision</b>(tseg, useg)</td>
            <td>Set minimum number of line segments making up curves in a patch.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>patchcurves</b>(nt, nu)</td>
            <td>Set the number of curves making up a patch.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>rpatch</b>(gx, gy, gz, gw)</td>
            <td>Draws a rational patch in the current basis, according to the geometry matrices gx, gy, gz, and gw.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>patch</b>(gx, gy, gz)</td>
            <td>Draws a patch in the current basis, according to the geometry matrices gx, gy, and gz.</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">POINT ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>point</b>(x, y, z)</td>
            <td>Draw a point at x, y, z</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>point2</b>(x, y)</td>
            <td>Draw a point at x, y.</td>
          </tr>
        </table>points are drawn with the current color and linewidth. Points are currently device-specific and may appear as circles, squares, or not at
        all; as they are generated by a zero-length vector using the hardware line style.
      </blockquote><a name=""></a>
      <h4><a name="">OBJECT ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>makeobj</b>(n)</td>
            <td>Commence the object number n.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>closeobj</b>()</td>
            <td>Close the current object.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>genobj</b>()</td>
            <td>Returns a unique object identifier.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getopenobj</b>()</td>
            <td>Return the number of the current object.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>callobj</b>(n)</td>
            <td>Draw object number n.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>isobj</b>(n)</td>
            <td>Returns non-zero if there is an object of number n.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>delobj</b>(n)</td>
            <td>Delete the object number n.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>loadobj</b>(n, filename)</td>
            <td>Load the object in the file filename as object number n.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>saveobj</b>(n, filename)</td>
            <td>Save object number n into file filename. Does NOT save objects called inside object n.</td>
          </tr>
        </table>Objects are graphical entities created by the drawing routines called between makeobj and closeobj. Objects may be called from within other
        objects. When an object is created most of the calculations required by the drawing routines called within it are done up to where the calculations
        involve the current transformation matrix. So if you need to draw the same thing several times on the screen but in different places it is faster to
        use objects than to call the appropriate drawing routines each time. Objects also have the advantage of being savable to a file, from where they can
        be reloaded for later reuse. Routines which draw or move in screen coordinates, or change device, cannot be included in objects.
      </blockquote><a name=""></a>
      <h4><a name="">DOUBLE BUFFERING</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>backbuffer</b>()</td>
            <td>Draw in the backbuffer. Returns <b>-1</b> if the device is not up to it.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>frontbuffer</b>()</td>
            <td>Draw in the front buffer. This will always work.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>swapbuffers</b>()</td>
            <td>Swap the front and back buffers.</td>
          </tr>
        </table>Where possible M_draw allows for front and back buffers to enable things like animation and smooth updating of the screen. The routine
        backbuffer is used to initialise double buffering.
      </blockquote><a name=""></a>
      <h4><a name="">POSITION ROUTINES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>getgp</b>(x, y, z)</td>
            <td>Gets the current graphics position</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getgpt</b>(x, y, z, w)</td>
            <td>Gets the current transformed graphics position in world coords.</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>getgp2</b>(x, y)</td>
            <td>Gets the current graphics position</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><b>sgetgp2</b>(x, y)</td>
            <td>Gets the current screen graphics position in screen coords (<b>-1</b> to 1)</td>
          </tr>
        </table>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_M_draw
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   use M_units,    only : cosd, sind
   implicit none
   integer  :: ipaws
   real     :: x1, y1
   integer  :: icolor
   integer  :: i,j
<br />      ! initialize image
      call prefsize(400,400)  ! set size before starting
      call vinit(' ')         ! start graphics using device $M_DRAW_DEVICEDEVICE
      call textsize(10.0,10.0)
      call mapcolor( 0,   255,255,255 )  !white
      call mapcolor( 1,   255,  0,  0 )  !red
      call mapcolor( 2,     0,255,  0 )  !green
      call mapcolor( 3,   255,255,  0 )  !yellow
      call mapcolor( 4,     0,  0,255 )  !blue
      call mapcolor( 5,   255,  0,255 )  !magenta
      call mapcolor( 6,     0,255,255 )  !cyan
      call mapcolor( 7,     0,  0,  0 )  !black
      call mapcolor( 8,     0,155,  0 )
      call mapcolor( 9,   155,155,155 )
      call mapcolor(10,   155,255,255 )
      call mapcolor(11,   155,155,  0 )
      call mapcolor(12,     0,  0,155 )
      call mapcolor(13,   155,  0,155 )
      call mapcolor(14,     0,155,155 )
      call mapcolor(15,   100,100,100 )
      call mapcolor(16,   155,100,100 )
      call color(D_BLACK)
      call clear()            ! clear to color 0
      call color(D_WHITE)
<br />      ! map area of virtual world to specified device area
      ! notice Y-axis for viewport is zero at TOP
      ! define the virtual world area we want to work in
      call page(0.0,  400.0,    0.0, 400.0)
      ! the drawing routines use these world units
<br />      ! put some colored boxes into pixmap by address
      ! so show how the pixel map can be edited easily with
      ! other routines that can manipulate a pixel array.
      ! The P_pixel array was created when vinit(3f) was called
      call polyfill(.true.)
      icolor=1
      do i=0,3
         do j=0,3
            x1=j*100.0
            y1=i*100.0
            icolor=icolor+1
            call color(icolor)
            call rect(x1,y1,x1+100.0,y1+100.0)
         enddo
      enddo
      call polyfill(.false.)
<br />      ! draw polar grids
      call linewidth(100)
<br />      call linewidth(100)
      call color(14)
      call target(200.0,200.0,200.0)
<br />      call linewidth(75)
      call color(0)
      call target(100.0,200.0,50.0)
<br />      ! draw some lines
      call color(D_RED)
      call linewidth(200)
      call line(1.0,1.0,400.0,400.0)
<br />      call color(D_BLUE)
      call linewidth(250)
      call line(350.0,200.0,350.0,300.0)
<br />      ! print some text
      call color(1)
      call linewidth(125)
      call font('futura.l')
      call hershey(40.0, 40.0,35.0,'Hello World',0.0)
      call color(7)
      call linewidth(25)
      call hershey(40.0, 80.0,35.0,'Hello World',0.0)
      call linewidth(100)
      call hershey(40.0,120.0,35.0,'Hello World',30.0)
<br />      call hershey(  40.0,350.0,35.0,'Hello World',0.0)
      call font('futura.m')
      call hershey(  40.0,310.0,35.0,'Hello World',0.0)
      call font('times.r')
      call hershey( 350.0,400.0,35.0,'Hello World',90.0)
      call linewidth(50)
      call font('times.i')
      call hershey(200.0,120.0,15.0,'Hello World',20.0)
<br />      ipaws=getkey()
      call vexit()
<br />      contains
<br />      subroutine target(xc,yc,rc)
      use M_units,    only : cosd, sind
      real     :: xc,yc,rc
      integer  :: i
      real     :: x,y
         do i=0,360,10
            x=rc*cosd(i)
            y=rc*sind(i)
            call line(xc,yc,xc+x,yc+y)
         enddo
         do i=1,int(rc),10
            call circle(xc,yc,real(i))
         enddo
      end subroutine target
<br />      subroutine line(x1,y1,x2,y2)
      real,intent(in) :: x1,y1,x2,y2
      call move2(x1,y1)
      call draw2(x2,y2)
      end subroutine line
<br />      subroutine hershey(x,y,height,itext,theta)
      real,intent(in)               :: x,y
      real,intent(in)               :: height
      character(len=*),intent(in)   :: itext
      real,intent(in)               :: theta
      call move2(x,y)
      call textang(theta)
      call textsize(height,height)
      call drawstr(itext)
      end subroutine hershey
   end program demo_M_draw
<br />
</pre>
      </blockquote><a name="4"></a>
      <h3><a name="4">BUGS</a></h3>
      <blockquote>
        <p>Polygon hatching will give unexpected results unless the polygon is initially defined in the X-Y plane.</p>
        <p>Double buffering isn't supported on all devices.</p>
        <p>We don't recommend the use of the smove/sdraw routines.</p>
        <p>The yobbarays may be turned on or they may be turned off.</p>
        <p>When creating an object, current position and text size are not actually changed so almost any query routine to get position or font size or
        whatever will not work properly.</p>
        <p>If call <b>vexit</b>(3f) and then call <b>vinit</b>(3f) everything should probably be reset to initial values at program startup, such as
        linewidth, current font, and color. It is currently left up to the output device initialization routine. It should not be. To minimize the issue,
        call all the push* routines after a <b>vinit</b>(3f) and call all the pop* routines before <b>vexit</b>(3f).</p>
        <p>Exactly what attributes should and should not be reset with a <b>vnewdev</b>(3f) is questionable.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c1"><img src="../images/M_draw.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c8">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>arc(3f)</b> - [M_draw:ARCS] Draw an arc in world units. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>arc</b>(<i>x</i>, <i>y</i>, <i>radius</i>, <i>startang</i>, <i>endang</i>)
<b>real,intent</b>(<i>in</i>) :: <i>x</i>
<b>real,intent</b>(<i>in</i>) :: <i>y</i>
<b>real,intent</b>(<i>in</i>) :: <i>radius</i>
<b>real,intent</b>(<i>in</i>) :: <i>startang</i>
<b>real,intent</b>(<i>in</i>) :: <i>endang</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Draw an arc. <i>x</i>, <i>y</i>, and <i>radius</i> are values <i>in</i> world units</p>
        <table cellpadding="3">
          <!-- tsb: Draw an arc. <I>x</I>, <I>y</I>, and <I>radius</I> are values <I>in</I> world units
 -->
          <tr valign="top">
            <td class="c9" width="6%" nowrap="nowrap">using</td>
            <td valign="bottom">current line width and color</td>
          </tr>
        </table>Angles are <i>in</i> degrees, positive measured counterclockwise from the +X axis. The current position after the arc is drawn is at the end
        of the arc.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c9" width="6%" nowrap="nowrap">X,Y</td>
            <td valign="bottom">Coordinates for the center of the circle</td>
          </tr>
          <tr valign="top">
            <td class="c9" width="6%" nowrap="nowrap">RADIUS</td>
            <td valign="bottom">Radius of the circle</td>
          </tr>
          <tr valign="top">
            <td class="c9" colspan="1">STARTANG</td>
            <td>Start angle</td>
          </tr>
          <tr valign="top">
            <td class="c9" width="6%" nowrap="nowrap">ENDANG</td>
            <td valign="bottom">End angle</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_arc
      use M_draw
      use M_draw,    only  : D_BLACK,   D_WHITE
      use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
      use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
      implicit none
      integer        :: icolor
      real           :: b=0.5
      real           :: R=4.9
      real           :: X, Y, A, YY
      integer        :: key
      call prefsize(1000,200)
      call vinit(' ')
      call color(D_BLACK)
      call clear()
      call color(D_YELLOW)
      call page(-25.0-b, 25.0+b, -5.0-b, 5.0+b)
      call textsize(1.0,1.4)
      call font("futura.l")
      call centertext(.true.)
      ! draw arcs with various start and end angles
<br />      X=-20.0; Y=0.0; A=0.0; B=30.0;  icolor=7; YY=4
      call drawit("0 to 30 deg.")
<br />      X=-10.0; YY=-4; A=0.0; B=-45.0; icolor=1
      call drawit("0 to -45 deg.")
<br />      X=0.0; YY=-4; A=100.0; B=200.0; icolor=2
      call drawit("100 to 200 deg.")
<br />      X=10.0; YY=-4; A=-30.0; B=30.0;icolor=5
      call drawit("-30 to 30 deg.")
<br />      YY=4; X=20.0; A=45.0; B=-45.0; icolor=6
      call drawit("45 to -45 deg.")
<br />      call vflush()
      key=getkey()
      call vexit()
   contains
      subroutine drawit(label)
         character(len=*) :: label
         call linewidth(150)
         call color(icolor)
         call arc(X,Y,R,A,B)
         call draw2(X,Y)
         call move2(X,YY)
         call linewidth(50)
         call color(D_WHITE)
         call drawstr(label)
      end subroutine drawit
<br />   end program demo_arc
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c8"><img src="../images/arc.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c16">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>backbuffer(3f)</b> - [M_draw:DOUBLE_BUFFERING] Draw in the backbuffer. Returns <b>-1</b> if the device is not up to it. <b></b>
      </blockquote><a name="contents" id="contents"></a>
        <pre>
integer function <b>backbuffer</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Make M_draw draw in the backbuffer. Returns <b>-1</b> if the device is not up to it.
      </blockquote>
      <hr />
      <br />
      <div class="c16"><img src="../images/backbuffer.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c19">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>backface(3f)</b> - [M_draw:POLYGONS] Turns on culling of backfacing polygons. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>backface</b>(<i>onoff</i>)
logical <i>onoff</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Turns on culling of backfacing polygons. A polygon is backfacing if its orientation in *screen* coords is clockwise, unless a call to backfacedir is
        made.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_backface
   !      demonstrate double buffering and what happens when you hit clipping plane
   !
   !      Specifying an extra argument turns on the filling.
   !
   use M_draw
   character(len=30) :: device
   character(len=1)  :: c
   real    r, t, dr, dt
   integer nplanes
   logical fill, back, backdir
   integer :: ios
<br />   print*,'Enter output device:'
   read(*,'(a)',iostat=ios)device
   if(ios.ne.0)device=' '
<br />   dr = 0.3
   dt = 0.2
   print*,'Enter delta in degrees (0.333 is typical):'
   read(*,*,iostat=ios) dr
   if(ios.ne.0)dr=0.333
   write(*,*)'DR=',dr
<br />   call prefsize(300, 300)
<br />   call vinit(device)
<br />   nplanes = getdepth()
<br />   fill = .true.
   back = .true.
   backdir = .true.
<br />   call polyfill(fill)
   call backface(back)
   call backfacedir(backdir)
<br />   call color(D_BLACK)
   call clear()
<br />   call window(-1.5, 1.5, -1.5, 1.5, 9.0, -5.0)
   call lookat(0.0, 0.0, 12.0, 0.0, 0.0, 0.0, 0.0)
<br />   t = 0.0
   r = 30.0
   !
   ! Setup drawing into the backbuffer....
   !
   if (backbuffer().lt.0) then
      write(*,*)'Device can''t support doublebuffering'
      ! draw a single view so at least the cube is displayed
      call frontbuffer()
      call color(D_BLACK)
      call clear()
      call translate(0.0, 0.0, t)
      call rotate(r, 'y')
      call rotate(r, 'z')
      call rotate(r, 'x')
      call color(D_WHITE)
      call polyfill(.true.)
      call drawcube(nplanes)
      call color(D_BLACK)
      call polyfill(.false.)
      call drawcube(nplanes)
      ipaws=getkey()
      call vexit()
      stop
<br />   endif
<br />   do
      if(r.ge.360) r = 0.0
      call color(D_BLACK)
      call clear()
<br />      call pushmatrix()
<br />      call translate(0.0, 0.0, t)
      call rotate(r, 'y')
      call rotate(r, 'z')
      call rotate(r, 'x')
      call color(D_WHITE)
<br />      call drawcube(nplanes)
<br />      if (nplanes .eq. 1 .and. fill) then
         call polyfill(.false.)
         call color(D_BLACK)
         call drawcube(nplanes)
         call polyfill(fill)
      endif
<br />      call popmatrix()
<br />      t = t + dt
      if (t.gt.3.0 .or. t.lt.-18.0) dt = -dt
<br />      call swapbuffers()
<br />      c = char(checkkey())
      if (c .eq. 'f') then
         fill = .not. fill
         call polyfill(fill)
      elseif (c .eq. 'b') then
         back = .not. back
         call backface(back)
      elseif (c .eq. 'd') then
         backdir = .not. backdir
         call backfacedir(backdir)
      elseif (c .ne. char(0)) then
         call vexit()
         stop
      endif
<br />      r = r + dr
   enddo
<br />   contains
   ! this routine draws the cube, using colours if available
   !
   subroutine drawcube(nplanes)
      integer nplanes
<br />      real carray(3, 8)
      data carray/            &amp;
      &amp;   -1.0,  -1.0,   1.0,  &amp;
      &amp;    1.0,  -1.0,   1.0,  &amp;
      &amp;    1.0,   1.0,   1.0,  &amp;
      &amp;   -1.0,   1.0,   1.0,  &amp;
      &amp;   -1.0,  -1.0,  -1.0,  &amp;
      &amp;    1.0,  -1.0,  -1.0,  &amp;
      &amp;    1.0,   1.0,  -1.0,  &amp;
      &amp;   -1.0,   1.0,  -1.0/
      save carray
<br />      if (nplanes.gt.1) call color(D_RED)
<br />      call makepoly()
      call move(carray(1,1), carray(2,1), carray(3,1))
      call draw(carray(1,2), carray(2,2), carray(3,2))
      call draw(carray(1,3), carray(2,3), carray(3,3))
      call draw(carray(1,4), carray(2,4), carray(3,4))
      call draw(carray(1,1), carray(2,1), carray(3,1))
      call closepoly()
<br />      if (nplanes.gt.1) call color(D_GREEN)
<br />      call makepoly()
      call move(carray(1,6), carray(2,6), carray(3,6))
      call draw(carray(1,5), carray(2,5), carray(3,5))
      call draw(carray(1,8), carray(2,8), carray(3,8))
      call draw(carray(1,7), carray(2,7), carray(3,7))
      call draw(carray(1,6), carray(2,6), carray(3,6))
      call closepoly()
<br />      if (nplanes.gt.1) call color(D_YELLOW)
<br />      call makepoly()
      call move(carray(1,2), carray(2,2), carray(3,2))
      call draw(carray(1,6), carray(2,6), carray(3,6))
      call draw(carray(1,7), carray(2,7), carray(3,7))
      call draw(carray(1,3), carray(2,3), carray(3,3))
      call draw(carray(1,2), carray(2,2), carray(3,2))
      call closepoly()
<br />      if (nplanes.gt.1) call color(D_BLUE)
<br />      call makepoly()
      call move(carray(1,1), carray(2,1), carray(3,1))
      call draw(carray(1,4), carray(2,4), carray(3,4))
      call draw(carray(1,8), carray(2,8), carray(3,8))
      call draw(carray(1,5), carray(2,5), carray(3,5))
      call draw(carray(1,1), carray(2,1), carray(3,1))
      call closepoly()
<br />      if (nplanes.gt.1) call color(D_MAGENTA)
<br />      call makepoly()
      call move(carray(1,3), carray(2,3), carray(3,3))
      call draw(carray(1,7), carray(2,7), carray(3,7))
      call draw(carray(1,8), carray(2,8), carray(3,8))
      call draw(carray(1,4), carray(2,4), carray(3,4))
      call draw(carray(1,3), carray(2,3), carray(3,3))
      call closepoly()
<br />      if (nplanes.gt.1) call color(D_CYAN)
<br />      call makepoly()
      call move(carray(1,1), carray(2,1), carray(3,1))
      call draw(carray(1,5), carray(2,5), carray(3,5))
      call draw(carray(1,6), carray(2,6), carray(3,6))
      call draw(carray(1,2), carray(2,2), carray(3,2))
      call draw(carray(1,1), carray(2,1), carray(3,1))
      call closepoly()
<br />   end subroutine drawcube
<br />   end program demo_backface
<br />
</pre>
      </blockquote>!
      <hr />
      <br />
      <div class="c19"><img src="../images/backface.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c22">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>backfacedir(3f)</b> - [M_draw:POLYGONS] Sets backfacing direction to clockwise or anti-clockwise <b></b>
      </blockquote><a name="contents" id="contents"></a>
        <pre>
subroutine <b>backfacedir</b>(<i>clockwise</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>clockwise</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Sets the backfacing direction to <i>clockwise</i> or anti-<i>clockwise</i> depending on whether <i>clockwise</i> is 1 or 0. 1 = <i>clockwise</i>
        (<i>in</i> screen coords) 0 = anticlockwise.
      </blockquote>
      <hr />
      <div class="c22"><img src="../images/backfacedir.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c25">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>bottomjustify(3f)</b> - [M_draw:TEXT] bottom justify text <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>bottomjustify</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Bottom justifies text. The text string will be drawn with the lower edge aligned with the current Y position. Top justification and Y centering
        are turned off.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_bottomjustify
   use M_draw
   implicit none
   real    :: x1, x2, y1, y2
   real    :: scl, ax, bx
   integer :: key
      call prefsize(1200,120)
      call vinit(' ')
      x1=0; x2=40; y1=0; y2=4; scl=1.9
      call page(x1,x2,y1,y2)
      call textsize(0.9*scl,1.4*scl)
      call font("times.rb")
      call linewidth(200)
      AX=(x1+x2)/2+1; BX=y1+1.3
      call move2(AX,BX)
      call bottomjustify()
      call color(D_BLUE)
      call drawstr("bottomjustify()")
      call color(D_RED)
      call move2(AX-1.0,BX)
      call draw2(AX+1.0,BX)
      call move2(AX,BX-1.0)
      call draw2(AX,BX+1.0)
      call vflush()
      key=getkey()
      call vexit()
   end program demo_bottomjustify
<br />
</pre>
      </blockquote>
      <hr />
      <table width="100%">
        <tr>
          <td width="33%"></td>
          <td width="33%" align="center">bottomjustify (3)</td>
          <td class="c26" align="right" width="33%">December 18, 2019</td>
        </tr>
      </table><span class="c27">Generated by <a href="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</a> from
      8ccd9f19-770d-4480-a3a1-fb266a3ac852 using man macros.</span><br />
      <br />
      <div class="c25"><img src="../images/bottomjustify.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c28">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>boxfit(3f)</b> - [M_draw:TEXT] resize the SOFTWARE text size so it fits in a box <b></b>
      </blockquote><a name="contents" id="contents"></a>
        <pre>
subroutine <b>boxfit</b>(<i>l</i>, <i>h</i>, <i>nchars</i>)
real <i>l</i>, <i>h</i>
integer <i>nchars</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set scale for text so that a string of the biggest characters in the font will fit in a box <i>l</i> by <i>h</i>. <i>l</i> and <i>h</i> are real
        values in world dimensions. This only applies to software text.
      </blockquote>
      <hr />
      <br />
      <div class="c28"><img src="../images/boxfit.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c31">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>boxtext(3f)</b> - [M_draw:TEXT] stretch and draw the SOFTWARE string s so that it fits in the imaginary box <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>boxtext</b>(<i>x</i>, <i>y</i>, <i>l</i>, <i>h</i>, <i>s</i>)
real <i>x</i>, <i>y</i>, <i>l</i>, <i>h</i>, <i>s</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw the string S so that it fits in the imaginary box defined with bottom left hand corner at (<i>x</i>, <i>y</i>), length <i>l</i>, and height
        <i>h</i>. This only applies to software text. The textsize is temporarily resized so that the string fills the specified box.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c32" width="6%" nowrap="nowrap">X,Y</td>
            <td valign="bottom">position of lower left corner of box in world coordinates</td>
          </tr>
          <tr valign="top">
            <td class="c32" width="6%" nowrap="nowrap">L</td>
            <td valign="bottom">length of box in world coordinates</td>
          </tr>
          <tr valign="top">
            <td class="c32" width="6%" nowrap="nowrap">H</td>
            <td valign="bottom">height of box in world coordinates</td>
          </tr>
          <tr valign="top">
            <td class="c32" width="6%" nowrap="nowrap">S</td>
            <td valign="bottom">string to stretch into box and draw</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Simple program:
        <pre>
    program demo_boxtext
    use M_draw,     only : vinit,vexit,prefsize,vgetdev,clear
    use M_draw,     only : centertext,polyfill,font,linewidth,color
    use M_draw,     only : getkey
    use M_draw,     only : color,rect,boxtext
    use M_draw,     only : D_BLACK,   D_WHITE
    use M_draw,     only : D_RED,     D_GREEN,    D_BLUE
    use M_draw,     only : D_YELLOW,  D_MAGENTA,  D_CYAN
    implicit none
    real              :: x1=0.0,    x2=40.0,    y1=0.0,    y2=7.0
    real              :: xmin=1.0,  xmax=39.0,  ymin=1.0,  ymax=6.0
    integer           :: idum
       call prefsize(int(x2-x1)*25,int(y2-y1)*25)
       call vinit(' ')
       call page(x1,x2,y1,y2)
       call centertext(.true.)
       call font("times.rb")
       call color(D_GREEN)
       call clear()
       call linewidth(200)
       call color(D_CYAN); call polyfill(.false.); call rect(xmin,ymin,xmax,ymax)
       call color(D_WHITE); call polyfill(.true.);  call rect(xmin,ymin,xmax,ymax)
       call color(D_BLACK)
       call boxtext(xmin,ymin,xmax-xmin,ymax-ymin,"This text is in the box")
       idum=getkey()
       call vexit()
    end program demo_boxtext
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c31"><img src="../images/boxtext.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c39">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>callobj(3f)</b> - [M_draw:OBJECT] Draw object number n. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>callobj</b>(<i>n</i>)
integer <i>n</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw object number <i>n</i>.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_callobj
      use M_draw
      implicit none
      integer :: ipaws
      integer :: ix, iy
      real    :: x, y
      integer :: icolor
<br />      ! set up graphics area
      call prefsize(680,680)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      !! Background color
      !call color(D_WHITE)
      !! Page setup
      !call page(0.0,2124.0,0.0,2124.0)
      !call color(D_BLACK)
<br />      call makeobj(1111)
      call circleprecision(300)
      call curveprecision(300)
<br />      icolor=0
      call mapcolor(icolor, 0, 0, 0); icolor=icolor+1
      call mapcolor(icolor, 0, 0, 255); icolor=icolor+1
      call mapcolor(icolor, 0, 255, 0); icolor=icolor+1
      call mapcolor(icolor, 0, 255, 255); icolor=icolor+1
      call mapcolor(icolor, 255, 0, 0); icolor=icolor+1
      call mapcolor(icolor, 255, 0, 255); icolor=icolor+1
      call mapcolor(icolor, 255, 255, 0); icolor=icolor+1
      call mapcolor(icolor, 255, 255, 255); icolor=icolor+1
      call mapcolor(icolor, 0, 0, 142); icolor=icolor+1
      call mapcolor(icolor, 0, 0, 175); icolor=icolor+1
      call mapcolor(icolor, 0, 0, 209); icolor=icolor+1
      call mapcolor(icolor, 135, 206, 255); icolor=icolor+1
      call mapcolor(icolor, 0, 142, 0); icolor=icolor+1
      call mapcolor(icolor, 0, 175, 0); icolor=icolor+1
      call mapcolor(icolor, 0, 209, 0); icolor=icolor+1
      call mapcolor(icolor, 0, 142, 142); icolor=icolor+1
      call mapcolor(icolor, 0, 175, 175); icolor=icolor+1
      call mapcolor(icolor, 0, 209, 209); icolor=icolor+1
      call mapcolor(icolor, 142, 0, 0); icolor=icolor+1
      call mapcolor(icolor, 175, 0, 0); icolor=icolor+1
      call mapcolor(icolor, 209, 0, 0); icolor=icolor+1
      call mapcolor(icolor, 142, 0, 142); icolor=icolor+1
      call mapcolor(icolor, 175, 0, 175); icolor=icolor+1
      call mapcolor(icolor, 209, 0, 209); icolor=icolor+1
      call mapcolor(icolor, 127, 48, 0); icolor=icolor+1
      call mapcolor(icolor, 160, 63, 0); icolor=icolor+1
      call mapcolor(icolor, 191, 96, 0); icolor=icolor+1
      call mapcolor(icolor, 255, 127, 127); icolor=icolor+1
      call mapcolor(icolor, 255, 160, 160); icolor=icolor+1
      call mapcolor(icolor, 255, 191, 191); icolor=icolor+1
      call mapcolor(icolor, 255, 224, 224); icolor=icolor+1
      call mapcolor(icolor, 255, 214, 0); icolor=icolor+1
      call mapcolor(icolor, 64, 64, 64); icolor=icolor+1
      call mapcolor(icolor, 128, 128, 128); icolor=icolor+1
      call mapcolor(icolor, 192, 192, 192); icolor=icolor+1
      call mapcolor(icolor, 224, 224, 224); icolor=icolor+1
      call mapcolor(icolor, 255, 255, 255); icolor=icolor+1
<br />      call polyfill(.true.)
<br />      ! Lower Pedestal Box
      call color(34-1)
      call rect(612.0, 537.0, 1512.0, 462.0)
      call polyfill(.false.)
      call rasters(5)
      call color(37-1)
      call rect(612.0, 537.0, 1512.0, 462.0)
      call polyfill(.true.)
      call rasters(1)
      ! Keyboard Surface
      call color(36-1)
      call makepoly()
      IX=237
      IY=462
      X=real(IX)
      Y=real(IY)
      call move2(X,Y)
      call pline([IX,IY,1887,462,2112,87,2112,12,12,12,12,87,IX,IY])
<br />      call closepoly()
      ! Upper Pedestal Box
      call color(34-1)
      call rect(687.0, 612.0, 1437.0, 537.0)
      call polyfill(.false.)
      call rasters(5)
      call color(37-1)
      call rect(687.0, 612.0, 1437.0, 537.0)
      call polyfill(.true.)
      call rasters(1)
<br />      ! Monitor Box
      call color(36-1)
      call rect(162.0, 2112.0, 1962.0, 612.0)
<br />      ! Main QWERTY area
      !edgewidth(0)
<br />      call color(37-1)
      call makepoly()
      call pline([312,387,162,162,1512,162,1437,387,312,387])
      call closepoly()
<br />      ! Numeric Keypad Area
      call makepoly()
      call pline([1812,387,1512,387,1587,162,1962,162,1812,387])
      call closepoly()
<br />      ! Shade Keyboard Front
      call color(35-1)
      call makepoly()
      call pline([12,87,12,12,2112,12,2112,87])
<br />      call closepoly()
      ! U-Shaped Edge of Keyboard Front for definition
      call rasters(5)
      call color(1-1)
      call pline([12,87,12,12,2112,12,2112,87])
<br />      ! Glass Tube/Viewing Panel
      call color(33-1)
      call rect(387.0, 1962.0, 1737.0, 762.0)
      ! Upper Edge of Recess
      call color(34-1)
      call makepoly()
      call pline([ &amp;
      &amp; 387,1887,388,1887,391,1887,396,1888,403,1888,413,1889,427,1890,443,1892,463,1893,484,1895, &amp;
      &amp; 508,1896,535,1898,562,1900,592,1902,622,1904,654,1906,687,1907,722,1909,759,1911,797,1912, &amp;
      &amp; 838,1913,881,1915,927,1916,975,1916,1025,1917,1077,1917,1133,1917,1187,1916,1238,1915,1285,1914, &amp;
      &amp; 1330,1913,1371,1911,1410,1910,1446,1908,1481,1906,1514,1904,1545,1902,1575,1900,1603,1898,1629,1896, &amp;
      &amp; 1653,1894,1674,1892,1692,1891,1707,1890,1719,1889,1727,1888,1733,1887,1736,1887,1737,1887,1738,1888, &amp;
      &amp; 1741,1891,1748,1898,1760,1910,1775,1925,1789,1939,1801,1951,1808,1958,1811,1961,1812,1962,1810,1962, &amp;
      &amp; 1807,1962,1800,1962,1789,1962,1773,1962,1752,1962,1725,1962,1692,1962,1653,1962,1607,1962,1555,1962, &amp;
      &amp; 1498,1962,1434,1962,1366,1962,1294,1962,1218,1962,1141,1962,1062,1962,983,1962,906,1962,830,1962, &amp;
      &amp; 758,1962,690,1962,626,1962,569,1962,517,1962,471,1962,432,1962,399,1962,372,1962,351,1962, &amp;
      &amp; 335,1962,324,1962,317,1962,314,1962,312,1962,313,1961,316,1958,323,1951,335,1939,350,1924, &amp;
      &amp; 364,1910,376,1898,383,1891,386,1888,387,1887])
      call closepoly()
<br />      ! Raised front of QWERTY area
      call rect(162.0, 162.0, 1512.0, 135.0)
<br />      ! Left Control Keys in QWERTY
      call color(35-1)
      call makepoly()
      call pline([284,387,162,162,387,162,418,237,366,237,396,312,348,312,387,387,284,387])
      call closepoly()
<br />      ! Right Control Keys in QWERTY
      call makepoly()
      call pline([1512,162,1287,162,1287,238,1336,237,1328,312,1362,312,1373,312,1358,387,1451,387,1512,162])
      call closepoly()
<br />      ! Numeric Keypad Special Keys -- Just Top?
      call makepoly()
      call pline([1962,162,1893,162,1812,342,1526,342,1511,387,1843,387,1962,162])
      call closepoly()
<br />      ! Raised Front of Numeric Keypad
      call color(34-1)
      call rect(1587.0,162.0,1962.0,136.0)
<br />      ! Left Raised Edge of Numeric Keypad
      call makepoly()
      call pline([1587,161,1586,134,1510,365,1511,386,1587,161])
      call closepoly()
<br />      ! Right Edge of Tube Recess
      call color(35-1)
      call makepoly()
      call pline([ &amp;
      &amp; 1812,762,1811,763,1808,766,1801,773,1789,785, &amp;
      &amp; 1774,800,1760,814,1748,826,1741,833,1738,836, &amp;
      &amp; 1737,837,1737,839,1737,843,1737,851,1737,863, &amp;
      &amp; 1737,881,1737,905,1737,934,1737,970,1737,1012, &amp;
      &amp; 1737,1060,1737,1113,1737,1171,1737,1232,1737,1297, &amp;
      &amp; 1737,1362,1737,1427,1737,1492,1737,1553,1737,1611, &amp;
      &amp; 1737,1664,1737,1712,1737,1754,1737,1790,1737,1819, &amp;
      &amp; 1737,1843,1737,1861,1737,1873,1737,1881,1737,1885, &amp;
      &amp; 1737,1887,1738,1888,1741,1891,1748,1898,1760,1910, &amp;
      &amp; 1775,1925,1789,1939,1801,1951,1808,1958,1811,1961, &amp;
      &amp; 1812,1962,1812,1960,1812,1956,1812,1948,1812,1937, &amp;
      &amp; 1812,1919,1812,1897,1812,1868,1812,1833,1812,1791, &amp;
      &amp; 1812,1744,1812,1690,1812,1631,1812,1568,1812,1502, &amp;
      &amp; 1812,1432,1812,1362,1812,1292,1812,1222,1812,1156, &amp;
      &amp; 1812,1093,1812,1034,1812,980,1812,933,1812,891, &amp;
      &amp; 1812,856,1812,827,1812,805,1812,787,1812,776, &amp;
      &amp; 1812,768,1812,764,1812,762])
      call closepoly()
<br />      ! Left Edge of Tube Recess
      call makepoly()
      call pline([ &amp;
      &amp; 312,762,313,763,316,766,323,773,335,785, &amp;
      &amp; 350,800,364,814,376,826,383,833,386,836, &amp;
      &amp; 387,837,387,839,387,843,387,851,387,863, &amp;
      &amp; 387,881,387,905,387,934,387,970,387,1012, &amp;
      &amp; 387,1060,387,1113,387,1171,387,1232,387,1297, &amp;
      &amp; 387,1362,387,1427,387,1492,387,1553,387,1611, &amp;
      &amp; 387,1664,387,1712,387,1754,387,1790,387,1819, &amp;
      &amp; 387,1843,387,1861,387,1873,387,1881,387,1885, &amp;
      &amp; 387,1887,386,1888,383,1891,376,1898,364,1910, &amp;
      &amp; 349,1925,335,1939,323,1951,316,1958,313,1961, &amp;
      &amp; 312,1962,312,1960,312,1956,312,1948,312,1937, &amp;
      &amp; 312,1919,312,1897,312,1868,312,1833,312,1791, &amp;
      &amp; 312,1744,312,1690,312,1631,312,1568,312,1502, &amp;
      &amp; 312,1432,312,1362,312,1292,312,1222,312,1156, &amp;
      &amp; 312,1093,312,1034,312,980,312,933,312,891, &amp;
      &amp; 312,856,312,827,312,805,312,787,312,776, &amp;
      &amp; 312,768,312,764,312,762])
<br />      call closepoly()
<br />      ! Bottom Edge of Tube Recess
      call color(37-1)
      call makepoly()
      call pline([ &amp;
      &amp; 387,837,388,837,391,837,396,836,403,836,413,835,427,834,443,832,463,831,484,829, &amp;
      &amp; 508,828,535,826,562,824,592,822,622,820,654,818,687,817,722,815,759,813,797,812, &amp;
      &amp; 838,811,881,809,927,808,975,808,1025,807,1077,807,1133,807,1187,808,1238,809,1285,810, &amp;
      &amp; 1330,811,1371,813,1410,814,1446,816,1481,818,1514,820,1545,822,1575,824,1603,826,1629,828, &amp;
      &amp; 1653,830,1674,832,1692,833,1707,834,1719,835,1727,836,1733,837,1736,837,1737,837,1738,836, &amp;
      &amp; 1741,833,1748,826,1760,814,1775,799,1789,785,1801,773,1808,766,1811,763,1812,762,1810,762, &amp;
      &amp; 1807,762,1800,762,1789,762,1773,762,1752,762,1725,762,1692,762,1653,762,1607,762,1555,762, &amp;
      &amp; 1498,762,1434,762,1366,762,1294,762,1218,762,1141,762,1062,762,983,762,906,762,830,762, &amp;
      &amp; 758,762,690,762,626,762,569,762,517,762,471,762,432,762,399,762,372,762,351,762, &amp;
      &amp; 335,762,324,762,317,762,314,762,312,762,313,763,316,766,323,773,335,785,350,800, &amp;
      &amp; 364,814,376,826,383,833,386,836,387,837])
      call closepoly()
<br />      ! &lt; of X11
      call color(8-1)
      call makepoly()
      call pline([1034,1233,927,1233,743,1463,987,1769,1034,1769,819,1493,1034,1233])
      call closepoly()
<br />      call rasters(5)
      call pline([1034,1233,927,1233,743,1463,987,1769,1034,1769,819,1493,1034,1233])
      call rasters(1)
<br />      ! &gt; of X11
      call color(8-1)
      call makepoly()
      call pline( [483,1769,591,1769,774,1540,530,1233,483,1233, 698,1509,483,1769])
      call closepoly()
<br />      call rasters(5)
      call pline( [483,1769,591,1769,774,1540,530,1233,483,1233,698,1509,483,1769])
      call rasters(1)
<br />      ! End of Picture %
<br />      call closeobj()
<br />      call makeobj(2222)
      call call_obj(1111,xt=-1012.0, yt=-1012.0)
      call closeobj()
<br />      !!call call_obj(2222)
<br />      ! make a big page and call object with various transformations
      call color(D_WHITE)
      call page( 0.0, 20000.0, 0.0, 20000.0)
      call clear()
      call color(D_BLACK)
<br />      call call_obj(1111, xs=4.0, ys=4.0)
      call call_obj(2222, xs=2.0, ys=2.0)
      call call_obj(2222, xs=2.0, ys=2.0, xt=10000.0, yt=10000.0)
      call call_obj(2222, xs=2.0, ys=2.0, xt=4000.0, yt=10000.0, zr=45.0)
      call call_obj(2222, xs=2.0, ys=2.0, yt=3000.0, xt=12000.0)
      call call_obj(2222, xs=1.4, ys=2.0, xt=13000.0, yt=16000.0, zr=180.0)
      call call_obj(2222, xs=1.0, ys=1.0, xt=16000.0, yt=16000.0, zr=0.0)
      call call_obj(2222, xs=4.0, ys=2.0, xt=6000.0, yt=17000.0)
      call call_obj(2222, xs=1.0, ys=1.0, xt=16000.0, yt=4000.0, zr=0.0)
      call call_obj(2222, xs=1.0, ys=1.0, xt=18000.0, yt=5500.0, zr=-30.0)
      call call_obj(2222, xs=1.0, ys=1.0, xt=16000.0, yt=7000.0, zr=30.0)
      call call_obj(2222, xs=1.0, ys=1.0, xt=18000.0, yt=9500.0, zr=-50.0)
      call call_obj(2222, xs=1.0, ys=1.0, xt=16000.0, yt=11000.0, zr=70.0)
<br />      ! this does not work as expected
      !call call_obj(2222, xs=2.0,, ys=2.0,, xt=16000.0, yt=13000.0, xr=10.0, yr=10.0 )
      !call call_obj(1111, xs=2.0,, ys=2.0,, xt=16000.0, yt=13000.0, xr=0.10, yr=0.10 )
<br />      ! pause
      call vflush()
      ipaws=getkey()
<br />      ! wrap up graphics
      call vexit()
<br />      contains
      subroutine pline(iarr)
         integer,intent(in) :: iarr(:)
         integer            :: i
         ! assuming nice data in x,y pairs
         call move2(real(iarr(1)),real(iarr(2)))
         do i=3,size(iarr),2
            call draw2(real(iarr(i)),real(iarr(i+1)))
         enddo
      end subroutine pline
<br />      subroutine call_obj(iobj,xt,yt,zt,xs,ys,zs,xr,yr,zr)
         ! DEFAULT call_obj(iobj,0.0,0.0,0.0, 1.0,1.0,1.0, 0.0,0.0.0.0)
         integer,intent(in) :: iobj
         real,optional :: xt,yt,zt
         real,optional :: xs,ys,zs
         real,optional :: xr,yr,zr
         real          :: xt_l,yt_l,zt_l
         real          :: xs_l,ys_l,zs_l
         real          :: xr_l,yr_l,zr_l
         if(present(xt))then; xt_l=xt; else; xt_l=0.0; endif
         if(present(yt))then; yt_l=yt; else; yt_l=0.0; endif
         if(present(zt))then; zt_l=zt; else; zt_l=0.0; endif
<br />         if(present(xs))then; xs_l=xs; else; xs_l=1.0; endif
         if(present(ys))then; ys_l=ys; else; ys_l=1.0; endif
         if(present(zs))then; zs_l=zs; else; zs_l=1.0; endif
<br />         if(present(xr))then; xr_l=xr; else; xr_l=0.0; endif
         if(present(yr))then; yr_l=yr; else; yr_l=0.0; endif
         if(present(zr))then; zr_l=zr; else; zr_l=0.0; endif
<br />         ! call an object using specified scaling, translation, and rotation
         ! and then restore coordinate space
         call pushmatrix()
            call translate(xt_l,yt_l,zt_l)
            call scale(xs_l,ys_l,zs_l)
            call rotate(xr_l,"x")
            call rotate(yr_l,"y")
            call rotate(zr_l,"z")
            call callobj(iobj)
         call popmatrix()
      end subroutine call_obj
<br />      subroutine rasters(iwidth)
         integer,intent(in) :: iwidth
         call linewidth(iwidth*5)
      end subroutine rasters
   end program demo_callobj
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c39"><img src="../images/callobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c42">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>centertext(3f)</b> - [M_draw:TEXT] Turns centertext mode on or off for SOFTWARE fonts. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>centertext</b>(<i>onoff</i>)
<b>logical,intent</b>(<i>in</i>) :: <i>onoff</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Turns centertext text on or off. Non-zero (.true.) is on. This centers strings and chars. This routine only affects software text.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c43" width="6%" nowrap="nowrap">ONOFF</td>
            <td valign="bottom">set centering mode on or off</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_centertext
   use :: M_draw
   use :: M_units, only : cosd, sind
   !! set up drawing environment
   call prefsize(600,600)
   call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
   call ortho2(-300.0,300.0,-300.0,300.0)
   call textsize(8.0,8.0)
   call linewidth(30)
   call color(D_BLACK)
   call clear()
<br />   x1=-150
   y1=-150
   do j=1,4
      select case(j)
      case(1);  call  xcentertext();        x1=-150;  y1=-150;  r=100
      case(2);  call  ycentertext();        x1=+150;  y1=-150;  r= 30
      case(3);  call  centertext(.true.);   x1=-150;  y1=+150;  r=100
      case(4);  call  centertext(.false.);  x1=+150;  y1=+150;  r= 30
      end select
      !! draw radial lines
      call color(D_RED)
      do i=1,80
         call move2(x1,y1)
         call draw2(x1+150.0*cosd(i*12), y1+150.0*sind(i*12))
      enddo
<br />      !! draw rotated text
      call color(D_GREEN)
      do i=1,30
         ang=i*12.0
         xx=x1+r*cosd(ang)
         yy=y1+r*sind(ang)
         call move2(xx,yy)
         call textang(ang)
         call color(D_WHITE)
         call drawstr('This is angled text')
         call color(D_RED)
      enddo
   enddo
<br />   ipaws=getkey()
<br />   call vexit()
<br />   end program demo_centertext
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c42"><img src="../images/centertext.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c46">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>checkkey(3f)</b> - [M_draw:INTERACTIVE] Returns zero if no key is pressed or ASCII ordinal <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>checkkey</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Returns zero if no key is pressed or the ASCII ordinal of the key that was pressed.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_checkkey
   use :: M_draw
   use :: M_units, only : cosd, sind
   use :: M_time, only : system_sleep
   !! set up drawing environment
   call prefsize(600,600)
   call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
   call ortho2(-300.0,300.0,-300.0,300.0)
   call textsize(500.0,500.0)
   call linewidth(130)
   call centertext(.true.)
   call color(D_BLACK)
   call clear()
   write(*,*)'press any character to see it displayed in the default font'
   write(*,*)'Enter "q" to quit'
   do
     ichar=checkkey()
     if(ichar.lt.0)then
        write(*,*)'this device does not support checkkey'
        exit
     elseif(ichar.ne.0)then
        call color(D_BLACK)
        call clear()
        call color(D_BLUE)
        call move2(0.0,0.0)
        call drawstr(char(ichar))
     endif
     call system_sleep(0.5)
     if(char(ichar).eq.'q')then
        write(*,*)'press any key to exit'
        ichar=getkey()
        exit
     endif
   enddo
   call vexit()
   end program demo_checkkey
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c46"><img src="../images/checkkey.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c49">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>circle(3f)</b> - [M_draw:ARCS] Draw a circle. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>circle</b>(<i>x</i>, <i>y</i>, <i>radius</i>)
<b>real,intent</b>(<i>in</i>) :: <i>x</i>
<b>real,intent</b>(<i>in</i>) :: <i>y</i>
<b>real,intent</b>(<i>in</i>) :: <i>radius</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Draw a circle. <i>x</i>, <i>y</i>, and <i>radius</i> are values <i>in</i> world units.</p>
        <p>Draw a circle using current line width and color</p>
      </blockquote><a name=""></a>
      <h4><a name="">NOTE</a></h4>
      <blockquote>
        <p>circles are regarded as polygons, so if polyfill or polyhatch has been called with .true., the circle will be filled or hatched accordingly.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c50" width="6%" nowrap="nowrap">X,Y</td>
            <td valign="bottom">Coordinates for the center of the circle</td>
          </tr>
          <tr valign="top">
            <td class="c50" width="6%" nowrap="nowrap">RADIUS</td>
            <td valign="bottom">Radius of the circle</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_circle
      use M_draw
      use M_drawPLUS, only : page
      use M_draw,    only  : D_BLACK,   D_WHITE
      use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
      use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
      implicit none
      real :: b=0.5
      real :: R=5
      integer :: ipaws
   ! set up drawing surface
      call prefsize(1000,200)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call page(-25.0-b,25.0+b,-R-b,R+b)
      call linewidth(200)
      call color(D_CYAN)
      call clear()
   ! draw circles with hatching and fill
      call color(D_WHITE)
      call circle(-20.0,0.0, R)
      call color(D_RED)
      call circle(-10.0,0.0, R)
      call polyfill(.true.)
      call color(D_GREEN)
      call circle(0.0,0.0,R)
      call linewidth(20)
      call polyhatch(.true.)
      call hatchpitch(1.0/2.0)
      call color(D_MAGENTA)
      call circle(10.0,0.0,R)
   ! layer calls to get a filled crosshatched circle
   ! first a solid colored circle
      call color(D_YELLOW)
      call polyfill(.true.)
      call circle(20.0,0.0,R)
<br />   ! draw hatch lines at 45 degrees
      call color(D_GREEN)
      call linewidth(80)
      call polyhatch(.true.)
      call hatchpitch(2.0/3.0)
      call hatchang(45.0)
      call circle(20.0,0.0,R)
   ! draw hatch lines at -45 degrees
      call hatchang(-45.0)
      call circle(20.0,0.0,R)
<br />   ! outline circle with a thick border
      call color(D_WHITE)
      call linewidth(160)
      call polyhatch(.false.)
      call circle(20.0,0.0,R)
<br />      ipaws=getkey()
   ! exit graphics mode
      call vexit()
   end program demo_circle
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c49"><img src="../images/circle.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c53">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>circleprecision(3f)</b> - [M_draw:ARCS] Set number of line segments used to approximate a circle <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>circleprecision</b>(<i>nsegs</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>nsegs</i>
</pre>
      </blockquote>
      <p>Set the number of line segments making up a circle. Default is currently</p>
      <blockquote>
        <table cellpadding="3">
          <!-- tsb: Set the number of line segments making up a circle. Default is currently
 -->
          <tr valign="top">
            <td width="4%">32.</td>
            <td>The number of segments <i>in</i> an arc or sector is calculated from the variable "<i>nsegs</i>" according to the span of the arc or
            sector.</td>
          </tr>
        </table>
      </blockquote>
      <p><a name="2"></a></p>
      <h3><a name="2">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c54" width="6%" nowrap="nowrap">NSEGS</td>
            <td valign="bottom">number of line segments making up a circle</td>
          </tr>
        </table>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_circleprecision
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   use M_drawPLUS, only : page
   use M_strings,  only : v2s
   real    :: b=0.5
   real    :: y1,y2,ym,x1,x2
   real    :: width=50.0/8.0,width2
   integer,parameter :: ivals(*)=[3,5,7,10,20,30,60,100]
   integer :: i
   integer :: ipaws
      !! set up long bar as plotting area
      call prefsize(1000,200)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call page(-25.0-b, 25.0+b, -5.0-b, 5.0+b)
      call textsize( 2.5/2.0, 3.0/2.0)
      call font('futura.l')
      call centertext(.true.)
      call linewidth(30)
      call color(D_GREEN)
      y1=-5
      y2=5
      ym=0
      x1=-25+.05*width
      ! draw colored rectangle and a circle and label center of circle repeat
      width2=width*0.95
      do i=1,size(ivals)
         x2=x1+width2
         call move2((x1+x2)/2.0,ym)
         call circleprecision(ivals(i))
         call drawstr((v2s(ivals(i))))     ! convert number to string and draw it
         call circle((x1+x2)/2.0, ym, (x2-x1)/2.10)
         x1=x1+width
      enddo
      ipaws=getkey()
      call vexit()
   end program demo_circleprecision
<br />
</pre>
      </blockquote><a name="4"></a>
      <h3><a name="4">IMAGE</a></h3>
      <blockquote>
        circles are drawn with various circle precision values.
      </blockquote>
      <hr />
      <br />
      <div class="c53"><img src="../images/circleprecision.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c57">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>clear(3f)</b> - [M_draw:COLOR] Clears screen to current color <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>clear</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Clears the screen to the current color. Causes a new page to begin on file-based devices that support multiple pages (Currently, the pixmap
        devices do not support multiple pages).</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_clear
     use M_draw, only  : prefsize, vinit, ortho2, clear, getkey
     use M_draw, only  : vexit, color, circle, polyfill
     use M_draw, only  : D_BLACK,   D_WHITE
     use M_draw, only  : D_RED,     D_GREEN,    D_BLUE
     use M_draw, only  : D_YELLOW,  D_MAGENTA,  D_CYAN
     implicit none
     integer :: ipaws
<br />     call prefsize(300,300)
     call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
     ipaws=getkey()
     call ortho2(-100.0,100.0,-100.0,100.0)
<br />     call color(D_BLACK)               ! set current  color
     call clear()                ! clear background to current color
     call color(D_RED)               ! set color to draw with
     call circle(0.0,0.0,50.0)
     ipaws=getkey()              ! pause for a keypress on interactive devices
<br />     call color(D_GREEN)               ! make a second page
     call clear()
     call polyfill(.true.)
     call color(D_YELLOW)
     call circle(0.0,0.0,50.0)
     ipaws=getkey()
<br />     call vexit()
<br />     end program demo_clear
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c57"><img src="../images/clear.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c60">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>clipping(3f)</b> - [M_draw:CLIPPING] Turn clipping on or off <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>clipping</b>(<i>onoff</i>)
<br />logical <i>onoff</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Turn clipping on or off. Non-zero is considered on. Note: on some devices turning clipping off may not be a good idea.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c60"><img src="../images/clipping.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c63">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>closeobj(3f)</b> - [M_draw:OBJECT] Close the current object. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>closeobj</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Close the current object.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c63"><img src="../images/closeobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c66">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>closepoly(3f)</b> - [M_draw:POLYGONS] Terminates a polygon opened by <b>makepoly</b>(3f) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>closepoly</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Terminates a polygon opened by <b>makepoly</b>(3f).</p>
      </blockquote>
      <hr />
      <br />
      <div class="c66"><img src="../images/closepoly.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c69">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>color(3f)</b> - [M_draw:COLOR] Set current color <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>color</b>(<i>col</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>col</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the current color. The standard colors are as follows:</p>
        <pre>
      d_black  =  0  d_red      =  1  d_green  =  2  d_yellow  =  3
      d_blue   =  4  d_magenta  =  5  d_cyan   =  6  d_white   =  7
<br />
</pre>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTION</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c70" width="6%" nowrap="nowrap">COL</td>
            <td valign="bottom">A color number from 0 to 255. To define additional colors see <b>mapcolor</b>(3f).</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_color
    use M_draw
    use M_drawPLUS, only : page
    use M_strings,  only : v2s
    real    :: b=0.5
    real    :: y1,y2,ym,x1,x2
    real    :: width=50.0/8.0,width2
    integer :: i
    integer :: ipaws
       !! set up long bar as plotting area
       call prefsize(1000,200)
       call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
       call page(-25.0-b, 25.0+b, -5.0-b, 5.0+b)
       call textsize( 3.5, 4.0)
       call font('futura.m')
       call centertext(.true.)
       call linewidth(90)
       y1=-5
       y2=5
       ym=0
       x1=-25+.05*width
       ! draw colored rectangle and a circle and label center of circle
       ! and repeat from colors 0 to 7.
       width2=width*0.95
       call linewidth(40)
       do i=0,7
          call color(i)
          x2=x1+width2
          call polyfill(.true.)
          call makepoly()
          call rect(x1,y1,x2,y2)
          call closepoly()
          call color(mod(i+1,7)+1)
          call move2((x1+x2)/2.0,ym)
          call drawstr((v2s(i)))     ! convert number to string and draw it
          call polyfill(.false.)
          call circle((x1+x2)/2.0, ym, (x2-x1)/2.10)
          x1=x1+width
       enddo
       ipaws=getkey()
       call vexit()
    end program demo_color
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c69"><img src="../images/color.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c73">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>curve(3f)</b> - [M_draw:CURVE] Draw a curve. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>curve</b>(<i>geom</i>)
real <i>geom</i>(3,4)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw a curve.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample Program:
        <pre>
   program demo_curve
   !
   !      using curves
   !
   use M_draw
<br />   integer i
   character(len=50) :: buf
   real bezier(4, 4), cardinal(4, 4), bspline(4, 4)
   real geom1(3, 4), geom2(3, 6)
   !
   ! curve basis types
   !
   data bezier /                                            &amp;
   &amp;          -1.0,   3.0,    -3.0,   1.0,                  &amp;
   &amp;          3.0,    -6.0,   3.0,    0.0,                  &amp;
   &amp;          -3.0,   3.0,    0.0,    0.0,                  &amp;
   &amp;          1.0,    0.0,    0.0,    0.0                   &amp;
   &amp;  /
<br />   data cardinal /                                          &amp;
   &amp;          -0.5,   1.5,    -1.5,   0.5,                  &amp;
   &amp;          1.0,    -2.5,   2.0,    -0.5,                 &amp;
   &amp;          -0.5,   0.0,    0.5,    0.0,                  &amp;
   &amp;          0.0,    1.0,    0.0,    0.0                   &amp;
   &amp;  /
<br />   data bspline /                                           &amp;
   &amp;          -0.166666,     0.5,     -0.5,     0.166666,   &amp;
   &amp;           0.5,         -1.0,      0.5,     0.0,        &amp;
   &amp;          -0.5,          0.0,      0.5,     0.0,        &amp;
   &amp;           0.166666,     0.666666, 0.166666, 0.0        &amp;
   &amp;  /
<br />   !
   ! Geometry matrix to demonstrate basic spline segments
   !
   data geom1 /                      &amp;
   &amp;           -180.0, 10.0, 0.0,    &amp;
   &amp;           -100.0, 110.0, 0.0,   &amp;
   &amp;           -100.0, -90.0, 0.0,   &amp;
   &amp;           0.0, 50.0, 0.0        &amp;
   &amp;  /
<br />   !
   ! Geometry matrix to demonstrate overlapping control points to
   ! produce continuous (Well, except for the bezier ones) curves
   ! from spline segments
   !
   data geom2 /                      &amp;
   &amp;          200.0, 480.0, 0.0,     &amp;
   &amp;          380.0, 180.0, 0.0,     &amp;
   &amp;          250.0, 430.0, 0.0,     &amp;
   &amp;          100.0, 130.0, 0.0,     &amp;
   &amp;          50.0,  280.0, 0.0,     &amp;
   &amp;          150.0, 380.0, 0.0      &amp;
   &amp;  /
<br /><br />   print*,'Enter output device:'
   read(*,'(a)',iostat=ios) buf
   if(ios.ne.0)buf=' '
<br />   call vinit(buf)
<br />   call ortho2(-200.0, 400.0, -100.0, 500.0)
<br />   call color(D_BLACK)
   call clear()
<br />   call color(D_YELLOW)
<br />   call textsize(10.0, 10.0)
   !
   ! label the control points in geom1
   !
   do i = 1, 4
      call move2(geom1(1, i), geom1(2, i))
      write(buf, '(i1)')i
      call drawstr(buf)
   enddo
   !
   ! label the control points in geom2
   !
   do i = 1, 6
      call move2(geom2(1, i), geom2(2, i))
      write(buf, '(i1)')i
      call drawstr(buf)
   enddo
   !
   ! scale the current font so that 30 of the largest characters
   ! in the current font will fit in a region 300 world units wide,
   ! 20 high.
   !
   call boxfit(300.0, 20.0, 30)
<br />   !
   ! set the number of line segments appearing in each curve to 20
   !
   call curveprecision(20)
<br />   !
   ! copy the bezier basis matrix into the curve basis matrix.
   !
   call curvebasis(bezier)
<br />   call color(D_RED)
<br />   !
   ! draw a curve using the current basis matrix (bezier in this case)
   ! and the control points in geom1
   !
   call curve(geom1)
<br />   call move2(70.0, 60.0)
   call drawstr('Bezier Curve Segment')
<br />   call move2(-190.0, 450.0)
   call drawstr('Three overlapping Bezier Curves')
<br />   !
   ! curven draws overlapping curve segments according to geom2, the
   ! number of curve segments drawn is three less than the number of
   ! points passed, assuming there are a least four points in the
   ! geometry matrix (in this case geom2). This call will draw 3
   ! overlapping curve segments in the current basis matrix - still
   ! bezier.
   !
   call curven(6, geom2)
<br />   idum=getkey()
   !
   ! load in the cardinal basis matrix
   !
   call curvebasis(cardinal)
<br />   call color(D_MAGENTA)
<br />   call move2(70.0, 10.0)
   call drawstr('Cardinal Curve Segment')
   !
   ! plot out a curve segment using the cardinal basis matrix
   !
   call curve(geom1)
<br />   call move2(-190.0, 400.0)
   call drawstr('Three overlapping Cardinal Curves')
   !
   ! now draw a bunch of them again.
   !
   call curven(6, geom2)
<br />   idum=getkey()
   !
   ! change the basis matrix again
   !
   call curvebasis(bspline)
<br />   call color(D_GREEN)
<br />   call move2(70.0, -40.0)
   call drawstr('Bspline Curve Segment')
   !
   ! now draw our curve segment in the new basis...
   !
   call curve(geom1)
<br />   call move2(-190.0, 350.0)
   call drawstr('Three overlapping Bspline Curves')
   !
   ! ...and do some overlapping ones
   !
   call curven(6, geom2)
<br />   idum=getkey()
<br />   call vexit()
<br />   end program demo_curve
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c73"><img src="../images/curve.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c76">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>curvebasis(3f)</b> - [M_draw:CURVE] Define a basis matrix for a curve. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>curvebasis</b>(<i>basis</i>)
<b>real,intent</b>(<i>in</i>) :: <i>basis</i>(4,4)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Define a <i>basis</i> matrix for a curve.
      </blockquote>
      <hr />
      <br />
      <div class="c76"><img src="../images/curvebasis.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c79">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>curven(3f)</b> - [M_draw:CURVE] Draw n-3 overlapping curve segments. Note: n must be at least 4. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>curven</b>(<i>n</i>, <i>geom</i>)
integer <i>n</i>
real <i>geom</i>(3,<i>n</i>)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw <i>n</i>-3 overlapping curve segments. Note: <i>n</i> must be at least 4.
      </blockquote>
      <hr />
      <br />
      <div class="c79"><img src="../images/curven.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c82">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>curveprecision(3f)</b> - [M_draw:CURVE] Define number of line segments used to draw a curve. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>curveprecision</b>(<i>nsegs</i>)
integer <i>nsegs</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Define the number of line segments used to draw a curve.
      </blockquote>
      <hr />
      <br />
      <div class="c82"><img src="../images/curveprecision.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c85">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>dashcode(3f)</b> - [M_draw:LINESTYLE] set dash pattern length <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>dashcode</b>(<i>dashlen</i>)
real <i>dashlen</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the current dash length (in world units) to be <i>dashlen</i>.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">IMAGE</a></h3>
      <blockquote>
        <p>The sample graphic shows a line segment being drawn using the same linestyle except the dashcode is being changed. Note that the dashcode is in
        world units,</p>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
  program demo_dashcode
  use M_draw
  implicit none
  integer        :: icolor
  integer        :: ikey
  real,parameter :: b=0.5
  real           :: x, y
  real           :: dcode
     call prefsize(1000,200)
     call vinit(' ')
     call color(D_BLACK)
     call clear()
     call page(-25.0-b, 25.0+b, -5.0-b, 5.0+b)
     call textsize(2.0, 2.4)
     call font("futura.m")
     call ycentertext()
     icolor=7; dcode=0.010/5.0; X=-23.0; Y=3.5  ; call line()
     icolor=1; dcode=0.025/5.0; X=-23.0; Y=-0.0 ; call line()
     icolor=2; dcode=0.030/5.0; X=-23.0; Y=-3.5 ; call line()
     icolor=4; dcode=0.050/5.0; X=0.0;   Y=3.5  ; call line()
     icolor=5; dcode=0.075/5.0; X=0.0;   Y=-0.0 ; call line()
     icolor=6; dcode=0.100/5.0; X=0.0;   Y=-3.5 ; call line()
     call linewidth(200)
     call color(D_BLUE)
     call move2(-25.0, -5.0)
     call draw2(-25.0,  5.0)
     call draw2(25.0,   5.0)
     call draw2(25.0,  -5.0)
     call draw2(-25.0, -5.0)
     ikey=getkey()
     call vexit()
  contains
  subroutine line
  character(len=6) :: string
     call linestyle('11100100')
     call dashcode(dcode)
     call color(icolor)
     call linewidth(70)
     call move2(X,Y)
     call rdraw2(10.0, 0.0)
     call rmove2(3.0, 0.0)
     call linestyle('')
     call linewidth(180)
     call color(D_WHITE)
     write(string,'(f6.3)')dcode
     call drawstr (string)
  end subroutine line
  end program demo_dashcode
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c85"><img src="../images/dashcode.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c88">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>delobj(3f)</b> - [M_draw:OBJECT] Delete the object number n. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>delobj</b>(<i>n</i>)
integer <i>n</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Delete the object number <i>n</i>.
      </blockquote>
      <hr />
      <br />
      <div class="c88"><img src="../images/delobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c91">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>draw(3f)</b> - [M_draw:DRAW] Draw from current graphics position to (x, y, z) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>draw</b>(<i>x</i>, <i>y</i>, <i>z</i>)
real <i>x</i>, <i>y</i>, <i>z</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Draw from current graphics position to (<i>x</i>, <i>y</i>, <i>z</i>). (<i>x</i>, <i>y</i>, <i>z</i>) is a point in world coordinates.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c91"><img src="../images/draw.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c94">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>draw2(3f)</b> - [M_draw:DRAW] Draw from current graphics position to given point (x, y) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>draw2</b>(<i>x</i>, <i>y</i>)
<b>real,intent</b>(<i>in</i>) :: <i>x</i>, <i>y</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw from current position to specified point using current color and line width. Updates current position to new point. (<i>x</i>, <i>y</i>) is a
        point <i>in</i> world coordinates.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c95" width="6%" nowrap="nowrap">X</td>
            <td valign="bottom">new X position</td>
          </tr>
          <tr valign="top">
            <td class="c95" width="6%" nowrap="nowrap">Y</td>
            <td valign="bottom">new Y position</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_draw2
   use M_draw,    only : prefsize, vinit, ortho2, clear, getkey
   use M_draw,    only : move2, draw2, vexit, color,linewidth
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   use M_units,   only : d2r, polar_to_cartesian
   !
   ! The Archimedean spiral is the locus of points corresponding
   ! to the locations over time of a point moving away from a
   ! fixed point with a constant speed along a line which rotates
   ! with constant angular velocity.
   !    r=A+B*theta
   ! Changing the parameter A will turn the spiral,
   ! while B controls the distance between successive turnings.
   !
      implicit none
      integer        :: i
      real           :: x,y,radius,theta
      real,parameter :: rotate=0.0, gap=2.0
      integer        :: ipaws
<br />      call prefsize(400,400)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call ortho2(-150.0,150.0,-150.0,150.0)
      call color(D_MAGENTA)
      call clear()
      call move2(0.0,0.0)
      call color(D_BLACK)
      call linewidth(40)
      do i=0,360*10,5
         theta=d2r(i)
         ! equation in polar coordinates
         radius=rotate+gap*theta
         ! convert polar coordinates to cartesian
         call polar_to_cartesian(radius,theta,x,y)
         ! draw from current position to end of next segment
         call draw2(x,y)
      enddo
      ipaws=getkey()
      ! exit graphics mode
      call vexit()
   end program demo_draw2
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c94"><img src="../images/draw2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c102">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>drawchar(3f)</b> - [M_draw:TEXT] Draw the character c and update current position. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>drawchar</b>(<i>ch</i>)
<b>character</b>(len=1),intent(<i>in</i>) :: <i>ch</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Draw the character c at the current position. The current graphics position represents the bottom left hand corner of the character space.</p>
        <p>Uses current line color and thickness and text justification mode.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_drawchar
   !
   !      display all the hershey fonts and demonstrate textang
   !
<br />   use M_draw, only: vinit, vsetflush, color, clear, font, vexit, vflush
   use M_draw, only: ortho2, textang, boxtext, rect, textsize, getkey
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   use M_draw
<br />   character(len=40)   :: str1, str2, str3, str4, fonts(22)
   character(len=100)  :: buf
   character(len=1)    :: c
   integer             :: i
   data fonts/ 'astrology', 'cursive',    'futura.l',               &amp;
   &amp;      'futura.m',  'gothic.eng', 'gothic.ger',             &amp;
   &amp;      'gothic.ita','greek',      'japanese',    'markers', &amp;
   &amp;      'math.low',  'math.upp',   'meteorology', 'music',   &amp;
   &amp;      'cyrillic',  'script',     'symbolic',    'times.g', &amp;
   &amp;      'times.ib',  'times.i',    'times.r',     'times.rb' /
<br />   data str1/ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' /
   data str2/ 'abcdefghijklmnopqrstuvwxyz' /
   data str3/ '1234567890+-=!@#$%^&amp;*(){}[]' /
   data str4/ '&lt;&gt;,./?~'\|_BONK,blark' /
   integer :: idum
   print*,'Enter output device:'
   read(*,'(a)',iostat=ios)buf
   if(ios.ne.0)buf=' '
   call prefsize(1000,1000)
   call vinit(buf)
   call vsetflush(.false.)
   call linewidth(20)
   call clear()
   ! define the world space
   call ortho2(-14.0, 14.0, -14.0, 14.0)
   do i = 1, 22
      ! do the title
      call textang(0.0)                 ! reset text angle so title is straight
      call color(D_CYAN)
      call font('futura.m')
      write(buf, '(''This is Hershey font '',a)') fonts(i)
      !call printattribs('before')
      call boxtext(-11.0, 12.0, 20.0, 1.0, buf)
      !call printattribs('after')
      call rect(-11.0, 12.0, 9.0, 13.0) ! draw a box around the title
      call font(fonts(i))               ! grab a font from the table
      call color(D_BLUE)
      ! show the outer ring
      call textsize(1.5, 1.5)
      call ShowCircularText(11.0, str1)
      ! show the second ring
      call textsize(1.3, 1.3)
      call ShowCircularText(8.5, str2)
      ! show the third ring
      call textsize(1.1, 1.1)
      call ShowCircularText(7.0, str3)
      ! show the inside ring
      call textsize(0.9, 0.9)
      call ShowCircularText(5.0, str4)
      call vflush()
<br />      idum= getkey()
      select case(idum)
       case(:-1,ichar('q'),ichar('Q'))
         exit
      end select
<br />      call color(D_BLACK)
      call clear()
   enddo
   call vexit()
   contains
<br />   subroutine ShowCircularText(r, str)  ! show a ring of text
      use M_draw, only : move2, textang, drawchar
<br />      real              :: r
      character(len=*)  :: str
      real              :: i, inc, x, y, a
      integer           :: j
      character(len=1)  :: c
      real,parameter    :: pi = 3.1415926535
<br />      j = 1
      inc = 360.0 / len_trim(str)
<br />      i=0.0
      do i10 = 1,len_trim(str)
         !
         ! calculate the next drawing position
         c = str(j:j)
         x = r * cos(i * pi / 180.0)
         y = r * sin(i * pi / 180.0)
         call move2(x, y)
         !
         ! calculate angle for next character
         a = 90.0 + i
         !
         ! set the orientation of the next character
         call textang(a)
         !
         ! draw the character
         call drawchar(c)
         j = j + 1
         i=i+inc
      enddo
<br />   end subroutine ShowCircularText
<br />   end program demo_drawchar
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c102"><img src="../images/drawchar.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c105">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>drawstr(3f)</b> - [M_draw:TEXT] Draw the text in string at the current position. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>drawstr</b>(<i>str</i>)
<b>character</b>(len=*),intent(<i>in</i>) :: <i>str</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw a text string at the current position. Uses current line color and thickness and text centering mode.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
      program demo_drawstr
      use M_draw
      call vinit('')
      ! by default the drawing surface is
      ! a square ranging from -1 to 1 in both
      ! the X and Y axis
<br />      call color(D_BLACK)    ! set current color to black
      call clear()           ! clear to current color
<br />      ! SET COMMON TEXT ATTRIBUTES
      call color(D_GREEN)    ! we want to draw in green
      call font('futura.m')  ! set font
      call textsize(0.1,0.1) ! font size
<br />      ! DRAW A STRING
      call move2(-1.0, 0.0)
      call drawstr('Hello')  ! draw string at current position
      ! note that current position is now at end of this string
<br />      ! CHANGE SOME TEXT ATTRIBUTES AGAIN
      call linewidth(20)     ! set line width
      call color(D_RED)      ! change color
      call textang(45.0)     ! change text angle
<br />      call drawstr(' World!')! draw string at current position
      idum=getkey()          ! pause
<br />      call vexit()           !  wrap up and exit graphics mode
<br />      end program demo_drawstr
      </blockquote>
      <hr />
      <br />
      <div class="c105"><img src="../images/drawstr.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c112">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>expandviewport(3f)</b> - [M_draw:VIEWPORT] use the entire device viewport <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>expandviewport</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>When M_draw does viewport calculations, it will normally begin by using the largest square it can fit onto the actual display device. This call
        says to use the whole device... however you must then take into account any distortion that will occur due to the non-square mapping. Thus, a
        viewport of (<b>-1.0</b>, 1.0, <b>-1.0</b>, 1.0) will map into the whole display device.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_expandviewport
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   implicit none
   integer :: ipaws
<br />   !! set up graphics area
   call prefsize(1000,200)
   call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
<br />   !! draw box that fills default world coordinate window
   call color(D_RED)
   call polyfill(.true.)
   call rect(-1.0, -1.0, 1.0, 1.0)
   call color(D_GREEN)
   call circle(0.0,0.0,1.0)
<br />   call expandviewport()
   !! the meaning of viewport numbers has now changed, but the
   !! viewport itself has not. Now &lt;-1,-1&gt; &lt;1,1&gt; defines the
   !! entire display area, where before it defined the largest square
   !! that would fit on the display
   call viewport(-1.0,1.0,-1.0,1.0)
   !! draw box that fills default world coordinate window again
<br />   !! instead of a square and circle, the mapping now
   !! produces an ellipse and rectangle unless this
   !! device has a square display
   call polyhatch(.true.)
   call hatchpitch(0.1)
   call hatchang(30.0)
   call linewidth(20)
   call color(D_CYAN)
   call rect(-1.0, -1.0, 1.0, 1.0)
   call color(D_YELLOW)
   call hatchang(120.0)
   call circle(0.0,0.0,1.0)
<br />   !! border
   call linewidth(100)
   call color(D_BLUE)
   call move2(-1.0, -1.0)
   call draw2(-1.0, 1.0)
   call draw2(1.0, 1.0)
   call draw2(1.0, -1.0)
   call draw2(-1.0, -1.0)
<br />   call vflush(); ipaws=getkey() !! pause
   call vexit()                  !! wrap up graphics
<br />   end program demo_expandviewport
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c112"><img src="../images/expandviewport.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c115">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>fixedwidth(3f)</b> - [M_draw:TEXT] Turns fixedwidth mode on or off for SOFTWARE fonts. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>fixedwidth</b>(<i>onoff</i>)
logical <i>onoff</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Turns fixedwidth text on or off. Non-zero (.true.) causes all text to be printed with a fixed width for each character. Otherwise, the text is
        spaced proportionally, where each character has a unique width less than or equal to the current fixed font width. This routine only affects
        software text.</p>
        <p>The default at program initialization is <b>fixedwidth</b>(.false.)</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_fixedwidth
      use M_draw
      implicit none
      real,parameter :: x1=0.0,  x2=40.0,  y1=0.0,  y2=4.0
      real,parameter :: scl=3*0.7
      integer :: idum
   ! set up display
      call prefsize(1000,100)
      call vinit(' ')
      call page(x1,x2,y1,y2)
   ! set font appearance
      call linewidth(200)
      call font("times.rb")
   ! draw a string using proportional and fixed spacing
      call move2(x1+0.3,y1+0.4)
      call textsize(0.8*scl,1.2*scl)
      call color(1)
      call fixedwidth(.false.)
      call drawstr("fixedwidth(.false.)")
      call textsize(0.6*scl,1.2*scl)
      call color(2)
      call fixedwidth(.true.)
      call drawstr(" fixedwidth(.true.)")
   ! wrap up
      idum=getkey()
      call vexit()
   end program demo_fixedwidth
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c115"><img src="../images/fixedwidth.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c118">
      </div>
      <p><a name="0"></a></p>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>font(3f)</b> - [M_draw:TEXT] Set the current font by name <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>font</b>(<i>fontname</i>)
<b>character</b>(len=*),intent(<i>in</i>) :: <i>fontname</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set the current font.
        <p>M_draw supports hardware and software fonts. The software fonts are based on the character set digitized by Dr Allen V. Hershey while working at
        the U. S. National Bureau of Standards. Exactly what hardware fonts are supported depends on the device, but it is guaranteed that the names "large"
        and "small" will result <i>in</i> something readable. For X11 displays the default large and small fonts used by the program can be overridden by
        placing the following defaults <i>in</i> the ~/.Xdefaults file:</p>
        <pre>
     draw.smallfont: X11-font-name
     draw.largefont: X11-font-name
<br />
</pre>It is noted here that hardware text is always assumed to be drawn parallel to the (x, y) plane, using whatever the current z coordinate is. The
following software fonts are supported:
        <pre>
      astrology       cursive         cyrillic        futura.l
      futura.m        gothic.eng      gothic.ger      gothic.ita
      greek           markers         math.low        math.upp
      meteorology     music           script          symbolic
      times.g         times.i         times.ib        times.r
      times.rb        japanese
<br />
</pre>A markers font "markers" is also provided for doing markers - you need to have centertext mode on for this to give sensible results when placing the
markers.
        <p>If the environment variable "M_draw_FONTPATH" is set M_draw looks for the software fonts <i>in</i> the directory given by this value.</p>
        <p>WHEN ASKED FOR NON-EXISTENT FONT NAMES, <b>FONT</b>(3f) STOPS THE PROGRAM.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample Program:
        <pre>
   program demo_font
   use :: M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   real    :: left
   real    :: baseline=80.0
   integer :: icolor=1
   integer :: ipaws
      !! set up drawing surface
      call prefsize(400, 400)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call page(-100.0, 100.0, -100.0, 100.0)
      call color(D_WHITE)
      call clear()
      call textsize(10.0, 10.0)
      !! place a vertical line along the edge
      call color(D_RED)
      call move2(-90.0, -90.0)
      call draw2(-90.0, 90.0)
      !! make a centered title at top a bit bolder and bigger
      call xcentertext()
      call textsize(13.0, 13.0)
      call linewidth(90)
      left=0
      call nextline('Font Samples')
      !! print the font samples
      left=-90
      call linewidth(40)
      call textsize(10.0, 10.0)
      call centertext(.false.)
      icolor=icolor-1
      call nextline('DEFAULT (ie. futura.l)')
      icolor=icolor-1
      call nextline('now call font(3f) ...')
      call nextline('A nice SIMPLEX font, futura.l')
      call nextline('A COMPLEX font, times.r')
      call nextline('ITALIC letters,  times.i')
      call nextline('DUPLEX is in between, futura.m')
      ipaws=getkey()
      call vexit()
   contains
   subroutine nextline(string)
   character(len=*) :: string
   !! reduce some duplicate code; very specific to this EXAMPLE
      integer :: iend
      iend=index(string,',')  ! if comma, assume font name found
      write(*,*)'FONT=',string(iend+1:),iend
      if(iend.ne.0)call font(trim(adjustl(string(iend+1:)))) ! change font
      icolor=icolor+1         ! set pen color
      call color(icolor)
      baseline=baseline-20    ! move down before drawing line
      call move2(left, baseline)
      call drawstr(string)    ! draw string
   end subroutine nextline
<br />   end program demo_font
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c118"><img src="../images/font.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c121">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>frontbuffer(3f)</b> - [M_draw:DOUBLE_BUFFERING] Draw in the front buffer. This will always work. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>frontbuffer</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Make M_draw draw in the front buffer. This will always work.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c121"><img src="../images/frontbuffer.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c124">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>genobj(3f)</b> - [M_draw:OBJECT] Returns a unique object identifier. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>genobj</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Returns a unique object identifier.
      </blockquote>
      <hr />
      <br />
      <div class="c124"><img src="../images/genobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c127">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getaspect(3f)</b> - [M_draw:ASPECT] Returns the ratio height over width of the display device. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
real function <b>getaspect</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Returns the ratio height over width of the display device.
      </blockquote>
      <hr />
      <br />
      <div class="c127"><img src="../images/getaspect.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c130">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getcharsize(3f)</b> - [M_draw:TEXT] Get the width and height of a character. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>getcharsize</b>(<i>c</i>, <i>width</i>, <i>height</i>)
character*1 <i>c</i>
real <i>width</i>, <i>height</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Get the <i>width</i> and <i>height</i> of a character. At the moment the <i>height</i> returned is always that of the difference between the maximum
        descender and ascender.
      </blockquote>
      <hr />
      <br />
      <div class="c130"><img src="../images/getcharsize.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c133">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getdepth(3f)</b> - [M_draw:DEVICE] Return number of bit planes (color planes) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>getdepth</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Returns the number of bit planes (or color planes) for a particular device. The number of colors displayable by the device is then 2**(nplanes); ie.
        if nplanes=1,then there are two colors (black and white).
      </blockquote>
      <hr />
      <br />
      <div class="c133"><img src="../images/getdepth.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c136">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getdisplaysize(3f)</b> - [M_draw:ASPECT] Returns width and height of device in device units <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>getdisplaysize</b>(<i>w</i>, <i>h</i>)
<b>real,intent</b>(<i>in</i>) :: <i>w</i>, <i>h</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Returns the width and height of the device <i>in</i> device units <i>in</i> <i>w</i> and <i>h</i> respectively.
      </blockquote>
      <hr />
      <br />
      <div class="c136"><img src="../images/getdisplaysize.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c139">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getfactors(3f)</b> - [M_draw:ASPECT] Returns width over <b>min</b>(width of device, height of device) and height over <b>min</b>(width of device,
        height of device). <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>getfactors</b>(<i>w</i>, <i>h</i>)
real <i>w</i>, <i>h</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Returns wfact as the width over <b>min</b>(width of device, height of device) and hfact as the height over <b>min</b>(width of device, height of
        device).
      </blockquote>
      <hr />
      <br />
      <div class="c139"><img src="../images/getfactors.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c142">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getfontdec(3f)</b> - [M_draw:TEXT] Return size of maximum font descender <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
real function <b>getfontdec</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Get the descender size of a character in a font.
      </blockquote>
      <hr />
      <br />
      <div class="c142"><img src="../images/getfontdec.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c145">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getfontsize(3f)</b> - [M_draw:TEXT] Get maximum width and height of a character in a font. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>getfontsize</b>(<i>width</i>, <i>height</i>)
real <i>width</i>, <i>height</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Get the maximum <i>width</i> and <i>height</i> of a character in a font.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c145"><img src="../images/getfontsize.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c148">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getgp(3f)</b> - [M_draw:POSITION] Gets the current graphics position <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>getgp</b>(<i>x</i>, <i>y</i>, <i>z</i>)
real <i>x</i>, <i>y</i>, <i>z</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Gets the current graphics position in world coords.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c148"><img src="../images/getgp.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c151">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getgp2(3f)</b> - [M_draw:POSITION] Gets the current graphics position in world coordinates <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>getgp2</b>(<i>x</i>, <i>y</i>)
<b>real,intent</b>(<i>out</i>) :: <i>x</i>,<i>y</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Gets the current graphics position in world coords.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c152" width="6%" nowrap="nowrap">X</td>
            <td valign="bottom">X coordinate of current position</td>
          </tr>
          <tr valign="top">
            <td class="c152" width="6%" nowrap="nowrap">Y</td>
            <td valign="bottom">Y coordinate of current position</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_getgp2
     use M_draw
     implicit none
     real :: X,Y
     call prefsize(20,20)
     call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
     call ortho2(-100.0,100.0,-100.0,100.0)
     call move2(0.0,0.0)
     call draw2(96.5,98.333)
<br />     call getgp2(X,Y)
     write(*,*)'CURRENT POSITION (X,Y)=',X,Y
<br />     call vexit()
     end program demo_getgp2
<br />
</pre>Results
        <pre>
   CURRENT POSITION (X,Y)=   96.5000000       98.3330002
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c151"><img src="../images/getgp2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c155">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getgpt(3f)</b> - [M_draw:POSITION] Gets the current transformed graphics position in world coords. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>getgpt</b>(<i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>)
real <i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Gets the current transformed graphics position in world coords.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c155"><img src="../images/getgpt.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c158">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getkey(3f)</b> - [M_draw:INTERACTIVE] Return ASCII ordinal of next key typed <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>getkey</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Return the ASCII ordinal of the next key typed at the keyboard. If the device has no keyboard <b>getkey</b>(3) returns <b>-1</b>.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_getkey
     use :: M_draw
     use :: M_units, only : cosd, sind
     use :: M_time, only : system_sleep
     !! set up drawing environment
     call prefsize(600,600)
     call voutput('+')
     call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
     call ortho2(-300.0,300.0,-300.0,300.0)
     call textsize(500.0,500.0)
     call linewidth(130)
     call centertext(.true.)
     call color(D_BLACK)
     call clear()
     write(*,*)'press any character to see it displayed in the default font'
     write(*,*)'Enter "q" to quit'
     do
       ichar=getkey()
       if(ichar.lt.0)then
          write(*,*)'this device does not support getkey'
          exit
       elseif(ichar.ne.0)then
          call color(D_BLACK)
          call clear()
          call color(D_BLUE)
          call move2(0.0,0.0)
          call drawstr(char(ichar))
       endif
       if(char(ichar).eq.'q')then
          write(*,*)'press any key to exit'
          ichar=getkey()
          exit
       endif
     enddo
     call vexit()
     end program demo_getkey
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c158"><img src="../images/getkey.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c161">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getopenobj(3f)</b> - [M_draw:OBJECT] Return the number of the current object. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>getopenobj</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Return the number of the current object.
      </blockquote>
      <hr />
      <br />
      <div class="c161"><img src="../images/getopenobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c164">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getstring(3f)</b> - [M_draw:INTERACTIVE] Read in a string, echoing it in current font <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="6">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>getstring</b>(<i>bcol</i>, <i>string</i>)
integer <i>bcol</i>
character *(*) <i>string</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Read in a <i>string</i>, echoing it in the current font, using the current color and the current transformation.</p>
        <p><b>getstring</b>(3f) interprets the Backspace key (ASCII 8) and the Del key (ASCII 127) as erasing characters. An EOT (ASCII 4) or a Carriage
        return (ASCII 13) will terminate input.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c165" width="6%" nowrap="nowrap">BCOL</td>
            <td valign="bottom">is the background color which is used for erasing characters after a backspace or a delete key is received.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <b>getstring</b>(3f) returns the number of characters read. Getstring does not check for overflow in the input buffer <i>string</i>.
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_getstring
   use M_draw
   ! reading a string from graphic input with getstring(3f)
   character(len=128) :: buf(10)
   character(len=20)  :: dev
   character(len=20)  :: fname
   integer            :: ios
<br />   print*, 'Enter device:'
   read (*, '(a)',iostat=ios) dev
   if(ios.ne.0)dev=' '
<br />   print*, 'Enter a font name:'
   read (*, '(a)',iostat=ios) fname
   if(ios.ne.0)fname='futura.l'
   if(fname.eq.'')fname='futura.l'
<br />   call vinit(dev)
<br />   call font(fname)
<br />   call clipping(.false.)
<br />   shft=0.14
   call window(-1.0-shft, 1.0-shft, -1.0, 1.0, 1.0, -1.0)
   call lookat(0.0-shft, 0.0-shft, 1.0, 0.0, 0.0, 0.0, 0.0)
<br />   call rotate(30.0, 'x')
   call rotate(30.0, 'z')
   call rotate(60.0, 'y')
<br />   call color(D_BLACK)
   call clear()
   call color(D_YELLOW)
<br />   tsize=0.25
   call textsize(tsize/2.5, tsize)
   call linewidth(100)
   call rect(-0.5, -0.5, 0.5, 0.5)
<br />   y=0.5
<br />   call linewidth(40)
   call move2(-0.5, y)
   call color(D_GREEN)
   call drawstr('getstring(3f) demo')
<br />   write(*,*)'Enter 10 lines up to 128 characters long.'
   write(*,*)'Program ends on blank line.'
<br />   do n=1,10
      y=y-tsize
      call move2(-0.5, y)
      i = getstring(D_BLACK, buf(n))
      write(*,'(/,a,i0,a,i0)',advance='no')'N=',n,' I=',i
      if(n.ge.1 .and. n.le.size(buf))write(*,*)' BUF=',trim(buf(n)(:i))
      buf(n)(min(128,i+1):)=' '
      if(i.le.0)exit ! exit on empty line
   enddo
<br />   call vexit()
<br />   do i = 1, n-1
      write(*, '(1x, ''Line'',i3,'' was: '', a)') i, buf(i)
   enddo
<br />   end program demo_getstring
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c164"><img src="../images/getstring.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c168">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>getviewport(3f)</b> - [M_draw:VIEWPORT] Returns limits of current viewport in screen coordinates <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>getviewport</b>(<i>left</i>, <i>right</i>, <i>bottom</i>, <i>top</i>)
<b>real,intent</b>(<i>out</i>) :: <i>left</i>
<b>real,intent</b>(<i>out</i>) :: <i>right</i>
<b>real,intent</b>(<i>out</i>) :: <i>bottom</i>
<b>real,intent</b>(<i>out</i>) :: <i>top</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Returns the <i>left</i>, <i>right</i>, <i>bottom</i> and <i>top</i> limits of the current viewport in screen coordinates (<b>-1.0</b> to
        1.0).</p>
        <pre>
   If a device has been declared to be real :: array(600,400)
<br />        o-----&gt; X                         (right=600,top=0)
        | #------------------------------------#
        | |                                    |
        | |                                    |
        V |                                    |
        Y |                                    |
          #------------------------------------#
</pre>(<i>left</i>=0,<i>bottom</i>=400)
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c169" width="6%" nowrap="nowrap">LEFT</td>
            <td valign="bottom">value for <i>left</i> side</td>
          </tr>
          <tr valign="top">
            <td class="c169" width="6%" nowrap="nowrap">RIGHT</td>
            <td valign="bottom">value for <i>right</i> side</td>
          </tr>
          <tr valign="top">
            <td class="c169" width="6%" nowrap="nowrap">BOTTOM</td>
            <td valign="bottom">value for <i>bottom</i> side</td>
          </tr>
          <tr valign="top">
            <td class="c169" width="6%" nowrap="nowrap">TOP</td>
            <td valign="bottom">value for <i>top</i> side</td>
          </tr>
        </table>
      </blockquote>
      <hr />
      <br />
      <div class="c168"><img src="../images/getviewport.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c172">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>hatchang(3f)</b> - [M_draw:POLYGONS] Set the angle of the hatch lines. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>hatchang</b>(<i>angle</i>)
<b>real,intent</b>(<i>in</i>) :: <i>angle</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the <i>angle</i> of the hatch lines. The <i>angle</i> is <i>in</i> degrees. Zero degrees is on the negative X axis. Positive values are
        counterclockwise. The value is 0 at program initialization. The last value set is retained even if hatching is not active or is turned on and
        off.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_hatchang
   use M_drawplus, only : draw_interpret
   character(len=:),allocatable :: draw_cmds(:)
<br />   DRAW_CMDS=[ CHARACTER(LEN=128) :: &amp;
   'prefsize 1000 200; vinit                                     ',&amp;
   'set b=.4; page -25-b 25+b -5-b 5+b; color 0;clear            ',&amp;
   'textsize .6 .7;font futura.l;centertext .true.               ',&amp;
   'leftjustify; linewidth 50; polyhatch .true.; hatchpitch 1/2  ',&amp;
   '# draw circles with hatching                                 ',&amp;
   'linewidth 90;hatchang  90.1; color  7;  circle X=-20  Y=0  5 ',&amp;
   'move2  X-4.9 Y=-4.9;color 7;linewidth 60;drawstr  90 degrees ',&amp;
   'linewidth 90;hatchang  45  ; color  2;  circle X=-10  Y=0  5 ',&amp;
   'move2  X-4.9 Y=-4.9;color 7;linewidth 60;drawstr  45 degrees ',&amp;
   'linewidth 90;hatchang   0  ; color  6;  circle X=-0   Y=0  5 ',&amp;
   'move2  X-4.9 Y=-4.9;color 7;linewidth 60;drawstr   0 degrees ',&amp;
   'linewidth 90;hatchang -45  ; color  5;  circle X=10   Y=0  5 ',&amp;
   'move2  X-4.9 Y=-4.9;color 7;linewidth 60;drawstr -45 degrees ',&amp;
   'linewidth 90;hatchang -90  ; color  4;  circle X=20   Y=0  5 ',&amp;
   'move2  X-4.9 Y=-4.9;color 7;linewidth 60;drawstr -90 degrees ',&amp;
   'linewidth 130                                                ',&amp;
   'move2 0 0;draw2 -5 0                                         ',&amp;
   'move2 -5 0;draw2 -4.4  0.3                                   ',&amp;
   'move2 -5 0;draw2 -4.4 -0.3                                   ',&amp;
   'rightjustify                                                 ',&amp;
   'linewidth 60                                                 ',&amp;
   'move2 -5 0;drawstr 0 degrees                                 ',&amp;
   'getkey                                                       ',&amp;
   'vexit                                                        ',&amp;
   '']
<br />   call draw_interpret(DRAW_CMDS,delimiters=';')
   end program demo_hatchang
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c172"><img src="../images/hatchang.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c175">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>hatchpitch(3f)</b> - [M_draw:POLYGONS] Set the distance between hatch lines. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>hatchpitch</b>(<i>pitch</i>)
<b>real,intent</b>(<i>in</i>) :: <i>pitch</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set the distance between hatch lines. The distance is measured <i>in</i> window units (as opposed to viewport or device units).
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_hatchpitch
   use M_drawplus, only : draw_interpret
   character(len=:),allocatable :: draw_cmds(:)
<br />   DRAW_CMDS=[ CHARACTER(LEN=128) :: &amp;
   'prefsize 1000 200; vinit                                                    ',&amp;
   'set b=.1; page -25-b 25+b -5-b 5+b;color 0;clear                            ',&amp;
   'textsize .5 .6;font futura.l; leftjustify                                   ',&amp;
   'circleprecision 3                                                           ',&amp;
   '# draw circles with hatching                                                ',&amp;
   'linewidth 150; polyhatch .true.; hatchang 30                                ',&amp;
   'hatchpitch 1/3 ; color 7; circle X=-20 0 5; move2 X-4.9 -4.9;color 7;drawstr 1/3',&amp;
   'hatchpitch 1/2 ; color 2; circle X=-10 0 5; move2 X-4.9 -4.9;color 7;drawstr 1/2',&amp;
   'hatchpitch  1  ; color 6; circle X=-0  0 5; move2 X-4.9 -4.9;color 7;drawstr 1',&amp;
   'hatchpitch  2  ; color 5; circle X=10  0 5; move2 X-4.9 -4.9;color 7;drawstr 2',&amp;
   'hatchpitch  3  ; color 4; circle X=20  0 5; move2 X-4.9 -4.9;color 7;drawstr 3',&amp;
   'getkey                                                                      ',&amp;
   'vexit                                                                       ',&amp;
   '']
<br />   call draw_interpret(DRAW_CMDS,delimiters=';')
   end program demo_hatchpitch
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c175"><img src="../images/hatchpitch.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c182">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>isobj(3f)</b> - [M_draw:OBJECT] Returns non-zero if there is an object of number n. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
logical function <b>isobj</b>(<i>n</i>)
integer :: <i>n</i>
</pre>
      </blockquote>
      <p><a name="2"></a></p>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Returns non-zero if there is an object of number <i>n</i>.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_isobj
   use M_draw
      call prefsize(300, 300)
      call prefposition(100, 100)
      call vinit(' ')   ! set up device
      call ortho2(-5.0,5.0,-5.0,5.0)
      call color(D_WHITE)  ! set current color
      call clear()   ! clear screen to current color
<br />      call makeobj(3)  ! create a simple object
         call polyfill(.true.)
         call color(D_GREEN)
         call circle(0.0,0.0,4.0)
      call closeobj()
<br />      if(isobj(3))then
         write(*,*)' 3 is an object (CORRECT)'
         call callobj(3)
      else
         write(*,*)' 3 is not an object (ERROR)'
      endif
<br />      if(isobj(4))then
         write(*,*)' 4 is an object (ERROR)'
      else
         write(*,*)' 4 is not an object (CORRECT)'
      endif
<br />      call callobj(4) ! note: calling a non-existent object is a no-op
<br />      idum=getkey()! wait for some input
      call vexit()!  set the screen back to its original state
<br />   end program demo_isobj
<br />
</pre>Expected output:
        <blockquote>
          <p>3 is an object (CORRECT) 4 is not an object (CORRECT)</p>
        </blockquote>
      </blockquote>
      <hr />
      <br />
      <div class="c182"><img src="../images/isobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c185">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>leftjustify(3f)</b> - [M_draw:TEXT] left justify text <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>leftjustify</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Left justifies text. The text string will begin at the current position and extend to the notional right. Right justification and X centering are
        turned off.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_leftjustify
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   implicit none
   real    :: x1, x2, y1, y2
   real    :: scl, ax, bx
   integer :: key
      call prefsize(1200,120)
      call vinit(' ')
      x1=0; x2=40; y1=0; y2=4; scl=1.9
      call page(x1,x2,y1,y2)
      call textsize(0.9*scl,1.4*scl)
      call font("times.rb")
      call linewidth(200)
      AX=(x1+x2)/2+1; BX=y1+1.3
      call move2(AX,BX)
      call leftjustify()
      call color(D_GREEN)
      call drawstr("leftjustify()")
      call color(D_RED)
      call move2(AX-1.0,BX)
      call draw2(AX+1.0,BX)
      call move2(AX,BX-1.0)
      call draw2(AX,BX+1.0)
      call vflush()
      key=getkey()
      call vexit()
   end program demo_leftjustify
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c185"><img src="../images/leftjustify.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c188">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>linestyle(3f)</b> - [M_draw:LINESTYLE] set the line dash pattern <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>linestyle</b>(<i>style</i>)
character *(*) <i>style</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the current linestyle to <i>style</i>. Linestyles are specified by giving a nominal length of a single dash and a character string consisting
        of 1's and 0's (zeros) that specify when to draw a dash and when not to draw a dash. "1" is for a dash , "0" is for a gap. Linestyles will follow
        curves and "go around" corners.</p>
        <p>To reset to a solid line <i>style</i>, enter a linestyle of " ". If a linestyle is set or reset, the accumulated information as to where on a
        curve (or line) a dash is to be draw is also reset.</p>
        <p>The sample program shows a line segment being drawn using the same dashcode (to specify dash length) except the linestyle is being changed. Note
        that the dashcode is in world units.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_linestyle
    ! A program showing basic line styles.
    use M_draw
    character(len=40) :: device
    integer           :: ios
<br />       print*,'Enter output device: '
       read(*,'(a)',iostat=ios)device
       if(ios.ne.0)device=' '
<br />       call prefsize(1000,1000)
       call vinit(device)
       call vsetflush(.true.)
       call up(0.0, 1.0, 0.0)
       call perspective(90.0, 1.0, 0.3, 3.0)
       call translate(0.0, 0.0, -1.3)
       call linewidth(30)
<br />       call drawscene()
       call rotate(-30.0, 'y')
       call rotate(-30.0, 'x')
       call drawscene()
<br />       call vexit()
       contains
<br />       subroutine drawscene()
<br />          call color(D_BLACK)
          call clear()
<br />          call color(D_GREEN)
          call dashcode(0.03)
<br />          call linestyle(' ')
          call xcentertext()
          call move2(-0.45, 0.9)
          call drawstr('Linestyle: "10"')
          call move2(-0.45, 0.7)
          call drawstr('Linestyle: "110"')
          call move2(-0.45, 0.5)
          call drawstr('Linestyle: "111010"')
          call move2(-0.45, 0.3)
          call drawstr('Linestyle: "0001"')
<br />          call linestyle('10')
          call move2(-0.9, 0.9)
          call draw2( 0.0, 0.9)
          call circle(0.6, 0.6, 0.4)
<br />          call drawbox(0.9)
          call drawsine(0.9)
<br />          call color(D_RED)
          call linestyle('110')
          call move2(-0.9, 0.7)
          call draw2( 0.0, 0.7)
          call circle(0.6, 0.6, 0.3)
          call drawbox(0.7)
          call drawsine(0.7)
<br />          call color(D_CYAN)
          call linestyle('111010')
          call move2(-0.9, 0.5)
          call draw2( 0.0, 0.5)
          call circle(0.6, 0.6, 0.2)
          call drawbox(0.5)
          call drawsine(0.5)
<br />          call color(D_YELLOW)
          call linestyle('0001')
          call move2(-0.9, 0.3)
          call draw2( 0.0, 0.3)
          call circle(0.6, 0.6, 0.1)
          call drawbox(0.3)
          call drawsine(0.3)
<br />          idum=getkey()
<br />          end subroutine drawscene
<br />          subroutine drawbox(scl)
          real :: scl
<br />          call pushmatrix()
<br />          call rotate(30.0, 'x')
          call rotate(60.0, 'y')
          call translate(-0.7, -1.2, 0.0)
          call scale(scl, scl, scl)
<br />          call move(0.0, 0.0, 0.0)
<br />          call draw(1.0, 0.0, 0.0)
          call draw(1.0, 1.0, 0.0)
          call draw(0.0, 1.0, 0.0)
          call draw(0.0, 0.0, 0.0)
<br />          call draw(0.0, 0.0, -1.0)
          call draw(1.0, 0.0, -1.0)
          call draw(1.0, 1.0, -1.0)
          call draw(0.0, 1.0, -1.0)
          call draw(0.0, 0.0, -1.0)
<br />          call move(0.0, 1.0, -1.0)
          call draw(0.0, 1.0, 0.0)
<br />          call move(1.0, 1.0, 0.0)
          call draw(1.0, 1.0, -1.0)
<br />          call move(1.0, 0.0, 0.0)
          call draw(1.0, 0.0, -1.0)
<br />          call popmatrix()
<br />          end subroutine drawbox
<br />          subroutine drawsine(s)
          real    s, RAD, AMP
          parameter(RAD = 0.5, AMP = 0.04)
          real    a, x, y, z
<br />          call pushmatrix()
<br />          call translate(RAD + 0.2, -0.5, 0.0)
          call scale(s, s, s)
<br />          call move(RAD, 0.0, 0.0)
          a=0.0
          do i10 = 0,2*314,2
             x = RAD * cos(a)
             z = RAD * sin(a)
             y = AMP * sin(a * 6.0)
<br />             call draw(x, y, z)
             a=a+0.02
          enddo
          call popmatrix()
          end subroutine drawsine
</pre>end program demo_linestyle
      </blockquote>
      <hr />
      <br />
      <div class="c188"><img src="../images/linestyle.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c191">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>linewidth(3f)</b> - [M_draw:LINESTYLE] set line width in rasters <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>linewidth</b>(<i>iwidth</i>)
integer <i>iwidth</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the current line width in units of 1/10,000 of the X size of the display surface</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_linewidth
   use M_draw,     only : prefsize, vinit, clear, getkey, drawstr
   use M_draw,     only : textsize, ycentertext, rdraw2, rmove2
   use M_draw,     only : move2, draw2, vexit, color, linewidth, font
   use M_draw,     only : D_BLACK,   D_WHITE
   use M_draw,     only : D_RED,     D_GREEN,    D_BLUE
   use M_draw,     only : D_YELLOW,  D_MAGENTA,  D_CYAN
   use M_drawPLUS, only : page
   implicit none
   real    :: b=0.5
   integer :: ipaws
   call prefsize(1000,200)
   call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
   call page(-25.0-b, 25.0+b, -5.0-b, 5.0+b)
   call color(D_YELLOW)
   call clear()
   call textsize(2.4,3.0)
   call font("futura.m")
   call ycentertext()
   ! draw circles with different precisions and label center of circles
   call color(D_WHITE)
   call linewidth(0)
   call move2(-20.0, -3.5)
   call rdraw2(10.0,0.0)
   call rmove2(3.0,0.0)
   call linewidth(180)
   call color(D_WHITE)
   call drawstr("0")
   call color(D_RED)
   call linewidth(100)
   call move2(-20.0,0.0)
   call rdraw2(10.0,0.0)
   call rmove2(3.0,0.0)
   call linewidth(180)
   call color(D_WHITE)
   call drawstr("100")
   call color(D_GREEN)
   call linewidth(200)
   call move2(-20.0,3.5)
   call rdraw2(10.0,0.0)
   call rmove2(3.0,0.0)
   call linewidth(180)
   call color(D_WHITE)
   call drawstr("200")
   call color(D_BLUE)
   call linewidth(300)
   call move2(3.0,-3.5)
   call rdraw2(10.0,0.0)
   call rmove2(3.0,0.0)
   call linewidth(180)
   call color(D_WHITE)
   call drawstr("300")
   call color(D_MAGENTA)
   call linewidth(400)
   call move2(3.0,0.0)
   call rdraw2(10.0,0.0)
   call rmove2(3.0,0.0)
   call linewidth(180)
   call color(D_WHITE)
   call drawstr("400")
   call color(D_CYAN)
   call linewidth(500)
   call move2(3.0,3.5)
   call rdraw2(10.0,0.0)
   call rmove2(3.0,0.0)
   call linewidth(180)
   call color(D_WHITE)
   call drawstr("500")
   call linewidth(200)
   call color(D_BLUE)
   call move2(-25.0,-5.0)
   call draw2(-25.0,5.0)
   call draw2(25.0,5.0)
   call draw2(25.0,-5.0)
   call draw2(-25.0,-5.0)
   ipaws=getkey()
   ! exit graphics mode
   call vexit()
   end program demo_linewidth
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c191"><img src="../images/linewidth.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c194">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>loadobj(3f)</b> - [M_draw:OBJECT] Load the object in the file filename as object number n. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>loadobj</b>(<i>n</i>, <i>filename</i>)
integer <i>n</i>
character*(*) <i>filename</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Load the object in the file "<i>filename</i>" as object number <i>n</i>.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_loadobj
   ! test some object-related procedures
   use M_draw
   integer                      :: env_len
   character(len=:),allocatable :: env
      !------------------------------------------------------------
      ! make an object file, which would normally be
      ! made by a separate program
      call voutput('+')
      call vinit('nil')   ! set up device
      call makeobj(3)
         call polyfill(.true.)
         call color(D_GREEN)
         call circle(0.0,0.0,4.0)
      call closeobj()
      call saveobj(3,"circle.obj")
      call vexit()
      !------------------------------------------------------------
      ! CURRENTLY:
      ! with multiple vinit(3f) calls the environment variable is
      ! not used without explicitly using it
      call get_environment_variable('M_DRAW_OUTPUT',LENGTH=env_len)
      if(env_len.ne.0)then
         allocate(character(len=env_len) :: env)
         call get_environment_variable('M_DRAW_OUTPUT',env)
         call voutput(env)
      endif
      !------------------------------------------------------------
      call prefsize(300, 300)
      call prefposition(100, 100)
      call vinit(' ')   ! set up device
      call ortho2(-5.1,5.3,-5.2,5.4)
      call color(D_WHITE)  ! set current color
      call clear()   ! clear screen to current color
      call color(D_BLUE)
      call move2(-5.0,-5.0)
      call draw2(5.0,5.0)
      call move2(-5.0,5.0)
      call draw2(5.0,-5.0)
      call loadobj(3,"circle.obj")
      call callobj(3)
      call translate(1.0,0.0,0.0)
      call translate(0.0,1.0,0.0)
      idum=getkey() ! wait for some input
      call vexit()  !  set the screen back to its original state
      !------------------------------------------------------------
   end program demo_loadobj
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c194"><img src="../images/loadobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c197">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>locator(3f)</b> - [M_draw:INTERACTIVE] Find out where cursor is <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>locator</b>(<i>xaddr</i>, <i>yaddr</i>)
real <i>xaddr</i>, <i>yaddr</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Find out where the cursor is. <i>xaddr</i> and <i>yaddr</i> are set to the current location in world coordinates. The function returns a bit
        pattern which indicates which buttons are being held down eg. if mouse buttons 1 and 3 are down locator returns binary 101 (decimal 7). The function
        returns <b>-1</b> if the device has no locator capability. Note: if you have been doing a lot of 3-D transformations <i>xaddr</i> and <i>yaddr</i>
        may not make a lot of sense. In this case use slocator.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
      program demo_locator !     track a cube with the locator
      use M_draw
      parameter(TRANS=20.0, SC=0.1)
      integer, parameter :: FACE=1, FILLED=2, OUTLINE=3
      character(len=10)  :: device
      character(len=1)   :: but
      logical            :: back, fill, hatch
      integer            :: ios
         write(*,*)'x,y,z = translate'
         write(*,*)'s     = apply scale'
         write(*,*)'+,-   = change scale/translate direction'
         write(*,*)'f,h   = fill, hatch'
         write(*,*)'b     = toggle backface'
         write(*,*)'q     = quit'
<br />         print*, 'Enter output device:'
         read(*, '(a)',iostat=ios) device
         if(ios.ne.0) device=' '
<br />         call prefposition(50, 50)
         call prefsize(500, 500)
<br />         call vinit(device)
<br />         call window(-800.0, 800.0, -800.0, 800.0, -800.0, 800.0)
         call lookat(0.0, 0.0, 1500.0, 0.0, 0.0, 0.0, 0.0)
<br />         tdir = TRANS
         scal = SC
<br />         !
         ! Start with a very ordinary filled cube like in the original demo...
         !
         call polyhatch(.false.)
         call hatchang(45.0)
         call hatchpitch(40.0)
         call polyfill(.true.)
<br />         fill = .true.
         hatch = .false.
         back = .true.
<br />         call makeobj(FACE)
         call makepoly()
         call rect(-200.0, -200.0, 200.0, 200.0)
         call closepoly()
         call closeobj()
<br />         call makecube(FILLED)
<br />         nplanes = getdepth()
         if (nplanes .eq. 1) call makecube(OUTLINE)
<br />         call backface(back)
         !
         ! Setup drawing into the backbuffer....
         !
         if (backbuffer().lt.0) then
            call vexit()
            write(*,*)'Device can''t support doublebuffering'
            stop
         endif
<br />         INFINITE: do
            idum = slocator(x, y)
            call pushmatrix()
            call rotate(100.0 * x, 'y')
            call rotate(100.0 * y, 'x')
            call color(D_BLACK)
            call clear()
            call callobj(FILLED)
            if (nplanes .eq. 1 .and. (fill .or. hatch)) call callobj(OUTLINE)
            call popmatrix()
            call swapbuffers()
<br />            but = char(checkkey())
            select case(but)
             case('x')
               call translate(tdir, 0.0, 0.0)
             case('y')
               call translate(0.0, tdir, 0.0)
             case('z')
               call translate(0.0, 0.0, tdir)
             case('s')
               call scale(scal, scal, scal)
             case('f')
               fill = .not. fill
               hatch = .false.
               call polyfill(fill)
             case('h')
               hatch = .not. hatch
               fill = .false.
               call polyhatch(hatch)
             case('b')
               back = .not. back
               call backface(back)
             case('-')
               tdir = -tdir
               if (scal .lt. 1.0) then
                  scal = 1.0 + SC
               else
                  scal = 1.0 - SC
               endif
             case('+')
               tdir = TRANS
             case('q',char(27))
               call vexit()
               stop
            end select
         enddo INFINITE
      contains
<br />      subroutine makecube(obj)
      integer obj
<br />         call makeobj(obj)
         if (obj .eq. OUTLINE) then
            call pushattributes()
            call color(D_BLACK)
            call polyfill(.false.)
            call polyhatch(.false.)
         endif
<br />         call pushmatrix()
         call translate(0.0, 0.0, 200.0)
         if (obj .eq. FILLED) call color(D_RED)
         call callobj(FACE)
         call popmatrix()
<br />         call pushmatrix()
         call translate(200.0, 0.0, 0.0)
         call rotate(90.0, 'y')
         if (obj .eq. FILLED) call color(D_GREEN)
         call callobj(FACE)
         call popmatrix()
<br />         call pushmatrix()
         call translate(0.0, 0.0, -200.0)
         call rotate(180.0, 'y')
         if (obj .eq. FILLED) call color(D_BLUE)
         call callobj(FACE)
         call popmatrix()
<br />         call pushmatrix()
         call translate(-200.0, 0.0, 0.0)
         call rotate(-90.0, 'y')
         if (obj .eq. FILLED) call color(D_CYAN)
         call callobj(FACE)
         call popmatrix()
<br />         call pushmatrix()
         call translate(0.0, 200.0, 0.0)
         call rotate(-90.0, 'x')
         if (obj .eq. FILLED) call color(D_MAGENTA)
         call callobj(FACE)
         call popmatrix()
<br />         call pushmatrix()
         call translate(0.0, -200.0, 0.0)
         call rotate(90.0, 'x')
         if (obj .eq. FILLED) call color(D_YELLOW)
         call callobj(FACE)
         call popmatrix()
<br />         if (obj .eq. OUTLINE) call popattributes()
<br />         call closeobj()
<br />
</pre>
        <blockquote>
          end subroutine makecube
          <p>end program demo_locator</p>
        </blockquote>
      </blockquote>
      <hr />
      <br />
      <div class="c197"><img src="../images/locator.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c200">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>lookat(3f)</b> - [M_draw:VIEWPORT] Specify the viewer's position <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>lookat</b>(<i>vx</i>, <i>vy</i>, <i>vz</i>, <i>px</i>, <i>py</i>, <i>pz</i>, <i>twist</i>)
real <i>vx</i>, <i>vy</i>, <i>vz</i>, <i>px</i>, <i>py</i>, <i>pz</i>, <i>twist</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Specify the viewer's position by giving a viewpoint and a reference point in world coordinates. A <i>twist</i> about the line of sight may also be
        given.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_lookat
   ! Demonstrate a rotating translating tetrahedron, and doublebuffering
   use M_draw
   use M_time, only : system_sleep
   !
   integer TETRAHEDRON
   parameter (TETRAHEDRON = 1)
   !
   real R, tx, tz, rotval, drotval, zeye
   integer i
   logical back, backdir, fill
   character(len=50) :: device
   integer :: ios
   !
   call prefsize(300, 300)
   !
   print*,'Enter output device:'
   read(*,'(a)',iostat=ios)device
   if(ios.ne.0)device=' '
   !
   back = .true.
   backdir = .true.
   fill = .true.
   !
   call vinit(device)
   !
   ! Make the tetrahedral object
   !
   call maketheobject()
   !
   rotval = 0.0
   drotval = 5.0
   zeye = 5.0
   !
   R = 1.6
   !
   tx = 0.0
   tz = R
   !
   !all polyfill(fill)
   call backface(back)
   call backfacedir(backdir)
   call clipping(.false.)
   !
   ! set up a perspective projection with a field of view of
   ! 40.0 degrees, aspect ratio of 1.0, near clipping plane 0.1,
   ! and the far clipping plane at 1000.0.
   !
   call perspective(40.0, 1.0, 0.001, 15.0)
   call lookat(0.0, 0.0, zeye, 0.0, 0.0, 0.0, 0.0)
   !
   ! Setup drawing into the backbuffer....
   !
   if (backbuffer().lt.0) then
      call vexit()
      write(*,*)'Device can''t support doublebuffering'
      stop
   endif
   !
   ! here we loop back here ad-naseum until someone hits a non interpreted key
   !
   INFINITE: do
   !
      rotval = 0.0
   !
      do i = 0, int(359.0 / drotval)
   !
         call color(D_BLACK)
         call clear()
   !
   !  Rotate the whole scene...(this accumulates - hence
   !  drotval)
   !
         call rotate(drotval * 0.1, 'x')
         call rotate(drotval * 0.1, 'z')
   !
         call color(D_RED)
         call pushmatrix()
         call polyfill(.false.)
         call rotate(90.0, 'x')
         call circle(0.0, 0.0, R)
         call polyfill(fill)
         call popmatrix()
   !
         call color(D_BLUE)
         call move(0.0, 0.0, 0.0)
         call draw(tx, 0.0, tz)
   !
   ! Remember! The order of the transformations is
   ! the reverse of what is specified here in between
   ! the pushmatrix and the popmatrix. These ones don't
   ! accumulate because of the push and pop.
   !
         call pushmatrix()
            call translate(tx, 0.0, tz)
            call rotate(rotval, 'x')
            call rotate(rotval, 'y')
            call rotate(rotval, 'z')
            call scale(0.4, 0.4, 0.4)
            call callobj(TETRAHEDRON)
         call popmatrix()
   !
         tz = R * cos(rotval * 3.1415926535 / 180)
         tx = R * sin(rotval * 3.1415926535 / 180)
   !
         call swapbuffers()
   !
         select case(char(checkkey()))
         case('f')
                   fill = .not. fill
                   call polyfill(fill)
         case('b')
                   back = .not. back
                   call backface(back)
         case('d')
                   backdir = .not. backdir
                   call backfacedir(backdir)
         case(char(0))
         case default
                   call vexit()
                   stop
          end select
   !
         rotval = rotval + drotval
   !
         call system_sleep(0.05)
   !
   enddo
   !
   enddo INFINITE
   !
   contains
   !
   ! maketheobject
   !
   !       generate a tetrahedron object as a series of move draws
   !
   subroutine maketheobject()
<br />   integer TETRAHEDRON, NSIDES, NFACES, NPNTS
   parameter (TETRAHEDRON = 1, NSIDES = 3, NFACES = 4, NPNTS = 4)
   integer colface(NFACES)
   real pnts(3, NPNTS)
   integer faces(NSIDES, NFACES)
   integer i, j
   real x, y, z
<br />   data pnts/               &amp;
        &amp;  -0.5, 0.866, -0.667,     &amp;
        &amp;  -0.5, -0.866, -0.667,    &amp;
        &amp;   1.0, 0.0, -0.667,       &amp;
        &amp;   0.0, 0.0, 1.334/
<br />   data colface/D_GREEN, D_YELLOW, D_CYAN, D_MAGENTA/
<br />   data faces/   &amp;
        &amp;  3, 2, 1,      &amp;
        &amp;  1, 2, 4,      &amp;
        &amp;  2, 3, 4,      &amp;
        &amp;  3, 1, 4/
<br />   call makeobj(TETRAHEDRON)
<br />   do i = 1, NFACES
      call makepoly()
      call color(colface(i))
      x = pnts(1, faces(1, i))
      y = pnts(2, faces(1, i))
      z = pnts(3, faces(1, i))
      call move(x, y, z)
      do j = 2, NSIDES
         x = pnts(1, faces(j,i))
         y = pnts(2, faces(j,i))
         z = pnts(3, faces(j,i))
         call draw(x, y, z)
      enddo
      call closepoly()
    enddo
<br />    call closeobj()
<br />    end subroutine maketheobject
<br />   end program demo_lookat
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c200"><img src="../images/lookat.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c203">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>makeobj(3f)</b> - [M_draw:OBJECT] Commence the object number n. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>makeobj</b>(<i>n</i>)
integer <i>n</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Commence the object number <i>n</i>.
      </blockquote>
      <hr />
      <br />
      <div class="c203"><img src="../images/makeobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c206">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>makepoly(3f)</b> - [M_draw:POLYGONS] opens polygon constructed by a series of move-draws and closed by closepoly <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>makepoly</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><b>makepoly</b>(3f)</td>
            <td>opens up a polygon which will then be constructed by a series of move-draws and closed by a closepoly.</td>
          </tr>
        </table>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_makepoly
   use :: M_draw
   implicit none
   integer,parameter :: wide=640, tall=640
   integer :: rows, xoff, yoff, box_sz
   integer :: i20, i30, ncols, nrows, ilines
   real    :: bottom, left, sun_radius, planet_radius, planet_offset
   integer :: ipaws
      call prefsize(wide,tall)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call ortho2(0.0, real(wide), 0.0, real(tall) )
      ! call linewidth(3) ! really slows down pbm driver because all lines are polygons
      call color(D_WHITE)
      call clear()
      call color(D_BLACK)
      rows=1
      box_sz=MIN(wide,tall)/rows       ! size of biggest box to use and get specified number of rows
      nrows = tall/box_sz              ! number of rows of objects to draw
      ncols = wide/box_sz              ! number of columns of objects to draw
      xoff = (wide - ncols * box_sz)/2 ! initial x offset to begin row at to center drawings
      yoff = (tall - nrows * box_sz)/2 ! initial x offset to begin column at to center drawings
      sun_radius = 148
      planet_radius = 1
      do ilines = 1, 300
         do i20 = 1, ncols
            left = (i20-1)*box_sz+xoff
            do i30 = 1, nrows
               bottom = (i30-1)*box_sz+yoff
               call color(D_BLACK)
            call makepoly()
               call rect(left,bottom,left+box_sz,bottom+box_sz)
            call closepoly()
               planet_offset= sun_radius
                  call color(mod(ilines,15)+1)
                  call hypoc(left + box_sz/2.0, bottom + box_sz/2.0, &amp;
               &amp; sun_radius, planet_radius, planet_offset, &amp;
               &amp; box_sz/2.0, ilines,  &amp;
               &amp; 0.0, 0.0, 1)
            enddo
         enddo
         ipaws=getkey()
      enddo
      call vexit()
   contains
   !
   !  Make shapes using hypocycloidal curves.
   !
   subroutine hypoc(xcenter,ycenter,sunr0,planet0,offset0,radius,ilines,ang,angs,ifill)
   use M_draw
   implicit none
   real,parameter     :: PI= 3.14159265358979323846264338327950288419716939937510
   real,intent(in)    :: xcenter, ycenter      ! center of curve
   real,intent(in)    :: sunr0,planet0,offset0 ! radii of sun, planet, and planet offset
   real,intent(in)    :: radius                ! radius to fit the shape to (no fit if radius is 0)
   integer,intent(in) :: ilines                ! number of points to sample along curve
   real,intent(in)    :: ang                   ! angle to rotate the shape by, to orientate it.
   real,intent(in)    :: angs                  ! angle to start sampling points at; ccw is +; 0 is East
   integer,intent(in) :: ifill                 ! 1 make a filled polygon, 2 make a hatched polygon
   integer            :: i10
   real               :: ang1, con1, con2, factor
   real               :: offset, planet, r, sunr, u
   real               :: xpoin, xpoin1, ypoin, ypoin1
      sunr=sunr0
      offset=offset0
      planet=planet0
      if(ilines.eq.0.0) return
      if(planet.eq.0.0) return
      if(sunr.eq.0.0)   return
      if(radius.ne.0.and.sunr-planet+offset.ne.0)then
         factor=radius/(sunr-planet+offset)
         sunr=factor*sunr
         planet=factor*planet
         offset=factor*offset
      endif
      u=0.0+ang
      con1=PI*2.*(sunr/planet)/real(ilines)
      con2=(1.0-planet/sunr)*u
      xpoin1=(sunr-planet)*cos(planet*u/sunr)+offset*cos(con2)
      ypoin1=(sunr-planet)*sin(planet*u/sunr)-offset*sin(con2)
      ang1=atan2(ypoin1,xpoin1)+angs
      r=sqrt(xpoin1**2+ypoin1**2)
      xpoin1=r*cos(ang1)+xcenter
      ypoin1=r*sin(ang1)+ycenter
      select case(ifill)
      case(:0)
      case(1:)
         call makepoly()
      end select
      call move2(xpoin1,ypoin1)
      do i10=1,ilines
         u=con1*i10+ang
         con2=(1.0-planet/sunr)*u
         if(con2.ge.2**24) con2=amod(con2,PI)
         xpoin=(sunr-planet)*cos(planet*u/sunr)+offset*cos(con2)
         ypoin=(sunr-planet)*sin(planet*u/sunr)-offset*sin(con2)
         ang1=atan2(ypoin,xpoin)+angs
         r=sqrt(xpoin**2+ypoin**2)
         xpoin=r*cos(ang1)+xcenter
         ypoin=r*sin(ang1)+ycenter
         call draw2(xpoin,ypoin)
      enddo
      call draw2(xpoin1,ypoin1)
      if(ifill.gt.0)then
        call closepoly()
      endif
   end subroutine hypoc
   end program demo_makepoly
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c206"><img src="../images/makepoly.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c209">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>mapcolor(3f)</b> - [M_draw:COLOR] set a color index using RGB values <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>mapcolor</b>(<i>indx</i>, <i>red</i>, <i>green</i>, <i>blue</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>indx</i>, <i>red</i>, <i>green</i>, <i>blue</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the color map index <i>indx</i> to the color represented by (<i>red</i>, <i>green</i>, <i>blue</i>). If the device has no color map this call
        does nothing.</p>
        <p>rgb values are <i>in</i> the range of 0 to 255.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c210" width="6%" nowrap="nowrap">INDX</td>
            <td valign="bottom">color index number, <i>in</i> range 0 to 255</td>
          </tr>
          <tr valign="top">
            <td class="c210" width="6%" nowrap="nowrap">RED</td>
            <td valign="bottom"><i>red</i> component of color being defined, <i>in</i> range 0 to 255</td>
          </tr>
          <tr valign="top">
            <td class="c210" width="6%" nowrap="nowrap">GREEN</td>
            <td valign="bottom"><i>green</i> component of color being defined, <i>in</i> range 0 to 255</td>
          </tr>
          <tr valign="top">
            <td class="c210" width="6%" nowrap="nowrap">BLUE</td>
            <td valign="bottom"><i>blue</i> component of color being defined, <i>in</i> range 0 to 255</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Color wheel EXAMPLE:
        <pre>
   program demo_mapcolor
   !   good program to exercise color tables, and look at differences
   !   when actual output device has a color table that is dynamic,
   !   or only has a small color table (a frame in this program takes
   !   at least SLICES*RINGS colors to produce accurately).
   use M_draw
   use m_color, only : hue
   use M_units, only : cosd, sind
   implicit none
      real                 :: lightstep
      integer              :: ii,iframe
      integer,parameter    :: SLICES=30
      integer,parameter    :: RINGS=  8
      real                 :: LIGHTNESS
      integer,parameter    :: BOX=1200
      integer              :: ipaws
      integer              :: istart, iend
      character(len=20)    :: device
      call prefsize(BOX,BOX)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call polyfill(.true.)
      call color(D_BLACK)
      call clear()
      call color(D_WHITE)
      call page(-110./2.,85./2.,-110./2.,110./2.)
      LIGHTNESS=100.0
      lightstep=-5
<br />      call vgetdev(device)
      select case(device)
      case ('p6','p3','ppm') ! just do one wheel
         istart=10
         iend=10
         LIGHTNESS=50.0
      case default           ! do many lightnesses
         istart=1
         iend=19
      end select
<br />      do ii=istart,iend
         iframe=ii
         call color(D_BLACK)
         call clear()
         call color(D_WHITE)
         call wheel()
         LIGHTNESS=LIGHTNESS+LIGHTSTEP
         ipaws=getkey()
      enddo
      call vexit()
   contains
   !=======================================================================--------
   subroutine wheel() ! draw an entire wheel
      character(len=40) :: inline
      real              :: hue_val
      integer           :: ii
      call textang(0.0)
      call color(D_WHITE)
      call textsize(5.0,6.0)
      call font('times.r')
      call move2(0.0,103.0/2.0)
      call centertext(.true.)
      call linewidth(30)
      call drawstr('COLOR WHEEL')
      call linewidth(0)
      call textsize( 2.5,2.5)
      call font('futura.l')
      call move2(0.0,90.0/2.0)
      write(inline,'("lightness=",f6.2)')LIGHTNESS
      call linewidth(30)
      call drawstr(inline)
      call linewidth(0)
      call textsize(1.5,1.5)
      hue_val=0
      do ii=SLICES, 1,-1
         call slice(hue_val)
      enddo
      call centertext(.false.)
   end subroutine wheel
   !=======================================================================--------
   subroutine slice(hue_val) ! draw a slice
      integer           :: buffer
      real              :: hue_val, ang_inc
      character(len=40) :: inline
      real              :: step
      real              :: X1, X2, X3, X4
      real              :: Y1, Y2, Y3, Y4
      !
      integer           :: maxcolors, current_color
      integer           :: ir, ig, ib
      real              :: r,g,b
      real              :: saturation
      !
      integer           :: status
      integer           :: icount
      real              :: angle1, angle2
      real              :: radius1, radius2, radius3, radius4
      !
      integer,save      :: color_count=0
      !
      buffer=8
      ANG_INC=360.0/SLICES
      angle1=hue_val-ANG_INC/2
      angle2=angle1+ANG_INC
      saturation=100
      radius1=32
      radius3=radius1+4
      radius4=radius1+7
      ! draw tic from wheel to start of angle label
      call color(D_WHITE)
      call linewidth(40)
      call move2( radius1*cosd(hue_val), radius1*sind(hue_val) )
      call draw2( radius3*cosd(hue_val), radius3*sind(hue_val) )
      ! draw degree label at tic
      call textang(hue_val)
      call move2( radius4*cosd(hue_val), radius4*sind(hue_val) )
      write(inline,'(i0)')nint(hue_val)
      call linewidth(20)
      call drawstr(inline)
      call linewidth(0)
      step=radius1/real(RINGS)
      radius2=radius1-step
      ! draw a chunk in a slice
      MAXCOLORS=(256)-buffer
      do icount=RINGS+1,2,-1
         CURRENT_COLOR=MOD(color_count,MAXCOLORS)+buffer  ! add buffer to leave base colors alone
         color_count=color_count+1
         ! fancy mapcolor
         call hue("hls",hue_val,LIGHTNESS,saturation,"rgb",r,g,b,status)
         ir=int(r*255.0/100.0+0.50)
         ig=int(g*255.0/100.0+0.50)
         ib=int(b*255.0/100.0+0.50)
         call mapcolor(CURRENT_COLOR,ir,ig,ib)
         call color(CURRENT_COLOR)
         !
         X1=cosd(angle1)*radius2
         Y1=sind(angle1)*radius2
         X2=cosd(angle1)*radius1
         Y2=sind(angle1)*radius1
         !
         X3=cosd(angle2)*radius2
         Y3=sind(angle2)*radius2
         X4=cosd(angle2)*radius1
         Y4=sind(angle2)*radius1
         !
         call makepoly()
         call move2(X1,Y1)
         call draw2(X2,Y2)
         call draw2(X4,Y4)
         call draw2(X3,Y3)
         call closepoly()
         !
         saturation=saturation-100.0/RINGS
         radius1=radius2
         radius2=radius1-step
      enddo
      hue_val=hue_val+ANG_INC
   end subroutine slice
   end program demo_mapcolor
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c209"><img src="../images/mapcolor.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c213">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>move(3f)</b> - [M_draw:MOVE] Move current graphics position to (x, y, z) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>move</b>(<i>x</i>, <i>y</i>, <i>z</i>)
real <i>x</i>, <i>y</i>, <i>z</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Move current graphics position to (<i>x</i>, <i>y</i>, <i>z</i>). (<i>x</i>, <i>y</i>, <i>z</i>) is a point in world coordinates.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c213"><img src="../images/move.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c216">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>move2(3f)</b> - [M_draw:MOVE] Move graphics position to point (x, y) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>move2</b>(<i>x</i>, <i>y</i>)
<b>real,intent</b>(<i>in</i>) :: <i>x</i>, <i>y</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Update current position. Move graphics position to point (<i>x</i>, <i>y</i>). (<i>x</i>, <i>y</i>) is a point <i>in</i> world coordinates.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c217" width="6%" nowrap="nowrap">X</td>
            <td valign="bottom">new X position</td>
          </tr>
          <tr valign="top">
            <td class="c217" width="6%" nowrap="nowrap">Y</td>
            <td valign="bottom">new Y position</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_move2
     use M_draw, only : prefsize, vinit, ortho2, clear, getkey
     use M_draw, only : move2, draw2, vexit, color
     use M_draw,    only  : D_BLACK,   D_WHITE
     use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
     use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
     implicit none
     integer :: ipaws
     call prefsize(60,40)
     call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
     call ortho2(-300.0,300.0,-200.0,200.0)
     call color(D_BLACK)
     call clear()
     call color(D_WHITE)
     call move2(-300.0,-200.0)
     call draw2(300.0,200.0)
     call move2(300.0,-200.0)
     call draw2(-300.0,200.0)
     ipaws=getkey()
     call vexit()
     end program demo_move2
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c216"><img src="../images/move2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c220">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>numchars(3f)</b> - [M_draw:TEXT] Return number of characters in the current SOFTWARE font. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>numchars</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Return the number of characters in the current font. Applicable only to software fonts.
      </blockquote>
      <hr />
      <br />
      <div class="c220"><img src="../images/numchars.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c223">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>ortho(3f)</b> - [M_draw:PROJECTION] Define x,y,z clipping planes. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>ortho</b>(<i>left</i>, <i>right</i>, <i>bottom</i>, <i>top</i>, <i>near_d</i>, <i>far_d</i>)
real <i>left</i>, <i>right</i>, <i>bottom</i>, <i>top</i>, <i>near_d</i>, <i>far_d</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Define x (<i>left</i>, <i>right</i>), y (<i>bottom</i>, <i>top</i>), and z (near, far) clipping planes. The near and far clipping planes are
        actually specified as distances along the line of sight. These distances can also be negative. The actual location of the clipping planes is z =
        -<i>near_d</i> and z = -<i>far_d</i>.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c223"><img src="../images/ortho.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c226">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>ortho2(3f)</b> - [M_draw:PROJECTION] define the area of the virtual world coordinates to map to the viewport <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>ortho2</b>(<i>left</i>, <i>right</i>, <i>bottom</i>, <i>top</i>)
<b>real,intent</b>(<i>in</i>) :: <i>left</i>, <i>right</i>, <i>bottom</i>, <i>top</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Defines the section of the virtual world coordinates to map to the viewport. That is, Define x (<i>left</i>, <i>right</i>), and y (<i>bottom</i>,
        <i>top</i>) clipping planes.</p>
        <p>All the projection routines define a new transformation matrix, and consequently the world units. Parallel projections are defined by ortho2.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c226"><img src="../images/ortho2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c229">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>page(3f)</b> - set window into largest viewport available </b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="6">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>page</b>(xsmall,xlarge,ysmall,ylarge)
<i>real</i>, <b>intent=</b>(<i>in</i>) :: xsmall
<i>real</i>, <b>intent=</b>(<i>in</i>) :: xlarge
<i>real</i>, <b>intent=</b>(<i>in</i>) :: ysmall
<i>real</i>, <b>intent=</b>(<i>in</i>) :: ylarge
<br />subroutine <b>page</b>(xsize,ysize,icolor)
</pre>
        <table cellpadding="3">
          <tr valign="top">
            <td colspan="1"><i>real</i>, <b>intent=</b>(<i>in</i>)</td>
            <td>:: xsize</td>
          </tr>
          <tr valign="top">
            <td colspan="1"><i>real</i>, <b>intent=</b>(<i>in</i>)</td>
            <td>:: ysize <i>integer</i>, <b>intent=</b>(<i>in</i>) :: icolor</td>
          </tr>
        </table>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        FORM SUBROUTINE <b>PAGE</b>(XSMALL,XLARGE,YSMALL,YLARGE)
        <p>Set the window to the rectangle defined by the corner points &lt;xsmall,ysmall&gt; and &lt;xlarge,ylarge&gt;.</p>
        <p>Also, given the window size, and assuming a one-to-one correspondence of window units (ie. an "x-unit" is as long as a "y-unit"), find the
        largest area on the display surface that has the same aspect ratio, and set the viewport to it.</p>
        <p>FORM SUBROUTINE <b>PAGE</b>(XSIZE,YSIZE,ICOLOR)</p>
        <p>Size the window to the rectangle defined by the corner points &lt;0.0,0.0&gt; and &lt;xsize,ysize&gt; and the viewport to the largest centered
        area that has the same aspect ratio, and set the background color to the value mapped to color ICOLOR.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_page
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   implicit none
   integer :: ipaws
   real,parameter :: radius=25.0
      call prefsize(600,600)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call page(-radius, radius, -radius, radius)
      call linewidth(200)
      call clear()
      call color(D_BLUE)
      call move2(-radius, -radius)
      call draw2(-radius, radius)
      call draw2(radius, radius)
      call draw2(radius, -radius)
      call draw2(-radius, -radius)
      call color(D_CYAN)
      call circle(0.0,0.0,radius)
      call vflush()
      ipaws=getkey()
      call vexit()
   end program demo_page
</pre>
      </blockquote><a name="4"></a>
      <hr />
      <br />
      <div class="c229"><img src="../images/page.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c232">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>patch(3f)</b> - [M_draw:PATCH] Draws a patch in the current basis, according to the geometry matrices gx, gy, and gz. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>patch</b>(<i>gx</i>, <i>gy</i>, <i>gz</i>)
<b>real,intent</b>(<i>in</i>) :: <i>gx</i>(4,4), <b>gy</b>(4,4), <i>gz</i>(4,4)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Draws a patch <i>in</i> the current basis, according to the geometry matrices <i>gx</i>, <i>gy</i>, and <i>gz</i>.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_patch
   !     Draws patches of various bases
   !
      use M_draw
      implicit none
   !
      character(len=20) :: dev
      integer           :: ios
      integer           :: i
      integer           :: idum
   !
   !  patch basis types
   !
      real bezier(4,4), cardinal(4, 4), bspline(4, 4)
      real power(4, 4)
      real x1(4, 4), y1(4, 4), z1(4, 4)
      real x2(4, 4), y2(4, 4), z2(4, 4)
     !
      character(len=50) :: labels(4)
     !
      real    basis(64)
      equivalence (basis(1), bezier(1, 1))
      equivalence (basis(17), cardinal(1, 1))
      equivalence (basis(33), bspline(1, 1))
      equivalence (basis(49), power(1, 1))
     !
      data bezier/                                            &amp;
      &amp;          -1.0,   3.0,    -3.0,   1.0,                 &amp;
      &amp;          3.0,    -6.0,   3.0,    0.0,                 &amp;
      &amp;          -3.0,   3.0,    0.0,    0.0,                 &amp;
      &amp;          1.0,    0.0,    0.0,    0.0/
     !
      data cardinal/                                          &amp;
      &amp;          -0.5,   1.5,    -1.5,   0.5,                 &amp;
      &amp;          1.0,    -2.5,   2.0,    -0.5,                &amp;
      &amp;          -0.5,   0.0,    0.5,    0.0,                 &amp;
      &amp;          0.0,    1.0,    0.0,    0.0/
     !
      data bspline/                                           &amp;
      &amp;          -0.166666,     0.5,     -0.5,     0.166666,  &amp;
      &amp;           0.5,         -1.0,      0.5,     0.0,       &amp;
      &amp;          -0.5,          0.0,      0.5,     0.0,       &amp;
      &amp;           0.166666,     0.666666, 0.166666, 0.0 /
     !
      data power/                                             &amp;
      &amp;          1.0, 0.0, 0.0, 0.0,                          &amp;
      &amp;          0.0, 1.0, 0.0, 0.0,                          &amp;
      &amp;          0.0, 0.0, 1.0, 0.0,                          &amp;
      &amp;          0.0, 0.0, 0.0, 1.0/
     !
      data    x1 /                                            &amp;
      &amp;          0.0,   0.2588,   0.5,   0.7071,              &amp;
      &amp;          0.0,   0.51764,  1.0,   1.4142,              &amp;
      &amp;          0.0,   0.51764,  1.0,   1.4142,              &amp;
      &amp;          0.0,   0.2588,   0.5,   0.7071/
     !
      data    y1 /                                            &amp;
      &amp;          1.0,   0.966,   0.866,  0.7071,              &amp;
      &amp;          2.0,   1.9318,  1.732,  1.4142,              &amp;
      &amp;          2.0,   1.9318,  1.732,  1.4142,              &amp;
      &amp;          1.0,   0.966,   0.866,  0.7071/
     !
      data    z1 /                                            &amp;
      &amp;          1.0,   1.0,     1.0,    1.0,                 &amp;
      &amp;          1.0,   1.0,     1.0,    1.0,                 &amp;
      &amp;          0.0,   0.0,     0.0,    0.0,                 &amp;
      &amp;          0.0,   0.0,     0.0,    0.0/
     !
      data    x2 /                                            &amp;
      &amp;          0.7071, 0.8660, 0.9660, 1.0,                 &amp;
      &amp;          1.4142, 1.7320, 1.932,  2.0,                 &amp;
      &amp;          1.4142, 1.7320, 1.932,  2.0,                 &amp;
      &amp;          0.7071, 0.8660, 0.9660, 1.0/
     !
      data    y2 /                                            &amp;
      &amp;          0.7071, 0.5,    0.2588, 0.0,                 &amp;
      &amp;          1.4142, 1.0,    0.5176, 0.0,                 &amp;
      &amp;          1.4142, 1.0,    0.5176, 0.0,                 &amp;
      &amp;          0.7071, 0.5,    0.2588, 0.0/
     !
      data    z2 /                                            &amp;
      &amp;          1.0,   1.0,     1.0,    1.0,                 &amp;
      &amp;          1.0,   1.0,     1.0,    1.0,                 &amp;
      &amp;          0.0,   0.0,     0.0,    0.0,                 &amp;
      &amp;          0.0,   0.0,     0.0,    0.0/
     !
      data labels /                                           &amp;
      &amp;          'Bezier Patch(es)',                          &amp;
      &amp;          'Cardinal Patch(es)',                        &amp;
      &amp;          'B-Spline Patch(es)',                        &amp;
      &amp;          '''Power'' Patch(es)' /
   !
   !  demonstrate patches
   !
      write (*,*)'Enter device:'
      read(*,'(a)',iostat=ios) dev
      if(ios.ne.0)dev=' '
   !
      call prefsize(1000,1000)
      call vinit(dev)
   !
      call vsetflush(.true.)
   !
      call color(D_BLACK)
      call clear()
   !
   ! Set up two viewports (They actually overlap)
   !
      call viewport(-1.0, 0.3, -1.0, 0.3)
      call ortho(-2.0, 5.0, -2.0, 5.0, -2.0, 5.0)
      call lookat(0.0, 0.0, 0.0, -3.0, 2.0, -4.0, 0.0)
   !
   !       Save it
   !
      call pushviewport()
      call pushmatrix()
   !
      call viewport(-0.3, 1.0, -0.3, 1.0)
      call ortho(-2.0, 5.0, -2.0, 5.0, -2.0, 5.0)
      call lookat(0.0, 0.0, 0.0, 3.0, 2.0, -4.0, 0.0)
   !
      call textsize(0.4, 0.4)
   !
   !  patchcurves provides a number of curves in the t and u
   !  directions. patchprecision gives the minimum number of line
   !  segments making up the curves in the t and u directions. The
   !  actual number of linesegments in t or u is equal to the closest
   !  integer multiple of the number of curves, &gt; nsegs, in t or u,
   !  greater than or equal to the number set by patchprecision in u or
   !  t. eg. curves in t will be made up of 21 line segments so that we
   !  can match up the 7 curves in u; curves in u will have 24 as 4 by 5
   !  gives 20.
   !
      call patchcurves(4, 7)
      call patchprecision(20, 20)
   !
      do 10 i = 0, 3
   !
         call axes()
   !
   !     patchbasis sets the basis matrices for the t and u
   !     functions
   !
   !
         call patchbasis(basis(i*16 + 1), basis(i*16 + 1))
   !
   !               Draw with viewport 2
   !
         call move(0.0, 4.0, 0.0)
         call drawstr(labels(i+1))
   !
   !     Now draw the patches according to the geometry matrices in
   !     x1, y1, and z1, x2, y2, z2.
   !
         call drawhull(x1, y1, z1)
         call patch(x1, y1, z1)
   !
         call drawhull(x2, y2, z2)
         call patch(x2, y2, z2)
   !
   !               Now with viewport 1
   !
         call popviewport()
         call popmatrix()
   !
         call axes()
   !
         call move(0.0, 4.0, 0.0)
         call drawstr(labels(i + 1))
   !
   !     now draw the patches according to the geometry matrices in
   !     x1, y1, and z1, x2, y2, z2.
   !
         call drawhull(x1, y1, z1)
         call patch(x1, y1, z1)
   !
         call drawhull(x2, y2, z2)
         call patch(x2, y2, z2)
   !
         idum=getkey()
   !
   !     Save viewport 1 again and reset to viewport 2
   !
         call pushviewport()
         call pushmatrix()
   !
         call viewport(-0.3, 1.0, -0.3, 1.0)
         call ortho(-1.5, 5.0, -1.5, 5.0, -1.5, 5.0)
         call lookat(0.0, 0.0, 0.0, 3.0, 2.0, -4.0, 0.0)
   !
         call color(D_BLACK)
         call clear()
   10 continue
   !
      call vexit()
   !
   contains
   !
      subroutine drawhull(x, y, z)
      implicit none
   !
      real    x(4,4), y(4,4), z(4,4)
      integer :: i
      integer :: j
   !
         call color(D_MAGENTA)
         do i = 1,4
            call move(x(i,1), y(i,1), z(i,1))
            do j = 1,4
               call draw(x(i,j), y(i,j), z(i,j))
            enddo
         enddo
   !
         do i = 1,4
            call move(x(1,i), y(1,i), z(1,i))
            do j = 1,4
               call draw(x(j,i), y(j,i), z(j,i))
            enddo
         enddo
   !
         call color(D_GREEN)
      end subroutine drawhull
   !
      subroutine axes()
   !
   !       draw the axes
   !
         call color(D_BLUE)
         call move(0.0, 0.0, 0.0)
         call draw(4.0, 0.0, 0.0)
<br />         call move(0.0, 0.0, 0.0)
         call draw(0.0, 4.0, 0.0)
<br />         call move(0.0, 0.0, 0.0)
         call draw(0.0, 0.0, 4.0)
   !
      end subroutine axes
   !
   end program demo_patch
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c232"><img src="../images/patch.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c235">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>patchbasis(3f)</b> - [M_draw:PATCH] Define the t and u basis matrices of a patch. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <blockquote>
        <pre>
subroutine <b>patchbasis</b>(<i>tbasis</i>, <i>ubasis</i>)
real :: <b>tbasis</b>(4,4), <i>ubasis</i>(4,4)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Define the t and u basis matrices of a patch.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c235"><img src="../images/patchbasis.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c238">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>patchcurves(3f)</b> - [M_draw:PATCH] Set the number of curves making up a patch. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>patchcurves</b>(<i>nt</i>, <i>nu</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>nt</i>, <i>nu</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the number of curves making up a patch.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c238"><img src="../images/patchcurves.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c241">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>patchprecision(3f)</b> - [M_draw:PATCH] Set minimum number of line segments making up curves in a patch. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>patchprecision</b>(<i>tseg</i>, <i>useg</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>tseg</i>, <i>useg</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set the minimum number of line segments making up curves <i>in</i> a patch.
      </blockquote>
      <hr />
      <br />
      <div class="c241"><img src="../images/patchprecision.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c244">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>perspective(3f)</b> - [M_draw:PROJECTION] Specify perspective viewing pyramid <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>perspective</b>(<i>fov</i>, <i>aspect</i>, <i>near</i>, <i>far</i>)
real <i>fov</i>, <i>aspect</i>, <i>near</i>, <i>far</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Specify a perspective viewing pyramid in world coordinates by giving a field of view, <i>aspect</i> ratio and the distance from the eye of the
        <i>near</i> and <i>far</i> clipping plane.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_perspective
   !
   !     Shows various combinations of viewing and projection transformations
   use M_draw
   !
   character(len=50) :: device
   integer :: ios
   !
      print*,'Enter output device:'
      read(*,'(a)',iostat=ios)device
      if(ios.ne.0)device=' '
   !
      call vinit(device)
   !
      call color(D_BLACK)
      call clear()
   !
   ! we want to draw just within the boundaries of the screen
   !
      call viewport(-0.9, 0.9, -0.9, 0.9)
   !
   ! set the world size
   !
      call ortho2(-5.0, 5.0, -5.0, 5.0)
   !
   ! draw a boundary frame
   !
      call color(D_RED)
      call rect(-5.0, -5.0, 5.0, 5.0)
   !
   ! set up a perspective projection with a field of view of
   ! 40.0 degrees, aspect ratio of 1.0, near clipping plane 0.1,
   ! and the far clipping plane at 1000.0.
   !
      call perspective(40.0, 1.0, 0.1, 1000.0)
   !
   ! we want the drawing to be done with our eye point at (5.0, 8.0, 5.0)
   ! looking towards (0.0, 0.0, 0.0). The last parameter gives a twist
   ! in degrees around the line of sight, in this case zero.
   !
      call lookat(5.0, 8.0, 5.0, 0.0, 0.0, 0.0, 0.0)
   !
      call drawtetra()
   !
   ! set the text size
   !
      call textsize(0.6, 0.9)
   !
      call move2(-4.5, -4.5)
      call drawstr('perspective/lookat')
   !
      idum=getkey()
   !
   ! window can also be used to give a perspective projection. Its
   ! arguments are 6 clipping planes, left, right, bottom, top, near,
   ! and far.
   !
      call window(-5.0, 5.0, -5.0, 5.0, -5.0, 5.0)
   !
   ! as window replaces the current transformation matrix we must
   ! specify our viewpoint again.
   !
      call lookat(5.0, 8.0, 5.0, 0.0, 0.0, 0.0, 0.0)
   !
      call color(D_BLACK)
      call clear()
   !
      call color(D_GREEN)
      call rect(-5.0, -5.0, 5.0, 5.0)
   !
      call drawtetra()
   !
      call textsize(0.6, 0.9)
      call move2(-4.5,-4.5)
      call drawstr('window/lookat')
   !
      idum=getkey()
   !
   ! set up our original perspective projection again.
   !
      call perspective(40.0, 1.0, 0.1, 1000.0)
   !
   ! polarview also specifies our viewpoint, but, unlike lookat, in polar
   ! coordinates. Its arguments are the distance from the world origin, an
   ! azimuthal angle in the x-y plane measured from the y axis, an
   ! incidence angle in the y-z plane measured from the z axis, and a
   ! twist around the line of sight.
   !
      call polarview(15.0, 30.0, 30.0, 30.0)
   !
      call color(D_BLACK)
      call clear()
   !
      call color(D_MAGENTA)
      call rect(-5.0, -5.0, 5.0, 5.0)
   !
      call drawtetra()
   !
      call move2(-4.5,-4.5)
      call textsize(0.6, 0.9)
      call drawstr('perspective/polarview')
   !
      idum=getkey()
   !
   ! once more with window for comparison
   !
      call window(-4.0, 4.0, -4.0, 4.0, -4.0, 4.0)
      call polarview(6.0, 20.0, -30.0, 70.0)
   !
      call color(D_BLACK)
      call clear()
   !
      call color(D_YELLOW)
      call rect(-5.0, -5.0, 5.0, 5.0)
   !
      call drawtetra()
   !
      call move2(-4.5,-4.5)
      call textsize(0.6, 0.9)
      call drawstr('window/polarview')
   !
      idum=getkey()
   !
      call vexit()
   !
   contains
   !
   subroutine drawtetra()
   !
   ! generate a tetrahedron as a series of move draws
   !
      call move(-0.5,  0.866, -0.5)
      call draw(-0.5, -0.866, -0.5)
      call draw( 1.0,  0.0,   -0.5)
      call draw(-0.5,  0.866, -0.5)
      call draw( 0.0,  0.0,    1.5)
      call draw(-0.5, -0.866, -0.5)
      call move( 1.0,  0.0,   -0.5)
      call draw( 0.0,  0.0,    1.5)
   !
   !    Label the vertices.
   !
      call color(D_WHITE)
      call textsize(0.3, 0.5)
      call move(-0.5,  0.866, -0.5)
      call drawchar('a')
      call move(-0.5, -0.866, -0.5)
      call drawchar('b')
      call move( 1.0,  0.0,   -0.5)
      call drawchar('c')
      call move( 0.0,  0.0,    1.5)
      call drawchar('d')
   !
   end subroutine drawtetra
   !
   end program demo_perspective
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c244"><img src="../images/perspective.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c247">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>point(3f)</b> - [M_draw:POINT] Draw a point at x, y, z <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>point</b>(<i>x</i>, <i>y</i>, <i>z</i>)
<b>real,intent</b>(<i>in</i>) :: <i>x</i>, <i>y</i>, <i>z</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw a point at <i>x</i>, <i>y</i>, <i>z</i>. The size of the point is not affected by perspective. Draw a polygon if you want perspective to be
        applied. The size of the point is controlled by the current linewidth.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_point
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   implicit none
   integer :: i
   integer :: ikey
      call prefsize(1000,200)
      call vinit(' ')
      call color(D_BLACK)
      call clear()
      call page(-25.0, 25.0, -5.0, 5.0)
<br />      ! draw points using various linewidths and colors
      do i=1,300
         call randpoint()
      enddo
<br />      ikey=getkey()
      call vexit()
<br />   contains
      subroutine randpoint()
         real :: r1, r2
         call random_number(r1)
         call random_number(r2)
         call linewidth(int(r1*500+200))
         call color(nint(r2*7))
         call point(r1*50.0-25.0,r2*10.0-5.0,0.0)
      end subroutine randpoint
<br />   end program demo_point
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c247"><img src="../images/point.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c250">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>point2(3f)</b> - [M_draw:POINT] Draw a point at x, y. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>point2</b>(<i>x</i>, <i>y</i>)
<b>real,intent</b>(<i>in</i>) :: <i>x</i>, <i>y</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw a point at <i>x</i>, <i>y</i>. Points are device-dependent and may not appear at all. Generally points are drawn with the current color as a
        circle with a diameter equal to the current linewidth.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_point2
   use :: M_draw
   implicit none
   integer :: i
   integer :: ipaws
   call prefsize(300,300)
   call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
   call ortho2(0.0, 20.0, 0.0, 20.0)
   call color(D_MAGENTA)
   do i=1,20
      call linewidth(20*i)
      call point2(real(i),real(i))
   enddo
   ipaws=getkey()
   call vexit()
   end program demo_point2
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c250"><img src="../images/point2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c253">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>polarview(3f)</b> - [M_draw:VIEWPORT] Specify the viewer's position in polar coordinates <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>polarview</b>(<i>dist</i>, <i>azim</i>, <i>inc</i>, <i>twist</i>)
real <i>dist</i>, <i>azim</i>, <i>inc</i>, <i>twist</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Specify the viewer's position in polar coordinates by giving the distance from the viewpoint to the world origin, the azimuthal angle in the x-y
        plane, measured from the y-axis, the incidence angle in the y-z plane, measured from the z-axis, and the <i>twist</i> angle about the line of
        sight.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c253"><img src="../images/polarview.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c256">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>poly(3f)</b> - [M_draw:POLYGONS] Construct a polygon from an array of points <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>poly</b>(<i>n</i>, <i>points</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>n</i>
<b>real,intent</b>(<i>in</i>) :: <b>points</b>(<i>3</i>, <i>n</i>)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Construct a polygon from an array of <i>points</i> provided by the user.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_poly
   use M_draw
   ! Using polygons, hatching, and filling.
   integer           :: ios
   character(len=50) :: device
      print*,'Enter output device:'
      read(*,'(a)',iostat=ios)device
      if(ios.ne.0)then
         call prefsize(1000,1000)
         device=' '
      endif
      call vinit(device)
   ! clear to black
      call color(D_BLACK)
      call clear()
   ! world coordinates are now in the range -10 to 10
   ! in x, y, and z. Note that positive z is towards us.
      call ortho(-10.0, 10.0, -10.0, 10.0, 10.0, -10.0)
      call color(D_YELLOW)
   ! write out the string "Polygon from poly()" in the
   ! starting at (-8.0, -4.0) and scaled to be 4.0 units long,
   ! 0.5 units high.
      call boxtext(-8.0, -4.0, 4.0, 0.5, 'Polygon from poly()')
      call color(D_GREEN)
   ! write out a scaled string starting at (0.0, 6.0)
      call boxtext(0.0, 6.0, 4.0, 0.5, 'Polygon from move()/ draw()')
      call color(D_MAGENTA)
   ! write out a scaled string starting at (0.0, 6.0)
      call boxtext(3.5, -3.5, 1.9, 0.5, 'Sector')
   ! draw some polygons
      call drawpoly()
   ! turn on polygon hatching
      call polyhatch(.true.)
      call hatchang(45.0)
      call hatchpitch(0.3)
   !  Rotate 20 degrees around x and 30 around y
      call rotate(20.0, 'x')
      call rotate(30.0, 'y')
   ! draw some polygons with hatching
      call drawpoly()
   ! turn on polygon filling - this automatically turns off hatching
      call polyfill(.true.)
   !  Do another set of rotations.
      call rotate(20.0, 'x')
      call rotate(30.0, 'y')
   ! draw some polygons with filling
      call drawpoly()
      call vexit()
   contains
   subroutine drawpoly()
      real parray(3,4)                   ! An array of points for a polygon
      data parray/ -8.0, -8.0, 0.0,  &amp;
                 &amp; -5.0, -8.0, 0.0,  &amp;
                 &amp; -5.0, -5.0, 0.0,  &amp;
                 &amp; -8.0, -5.0, 0.0 /
      call color(D_YELLOW)
   ! Draw a polygon using poly, parray is our array of
   ! points and 4 is the number of points in it.
      call poly(4, parray)
      call color(D_GREEN)
   ! Draw a 5 sided figure by using move, draw and closepoly.
      call makepoly()
         call move(0.0, 0.0, 0.0)
         call draw(3.0, 0.0, 0.0)
         call draw(3.0, 4.0, 0.0)
         call draw(-1.0, 5.0, 0.0)
         call draw(-2.0, 2.0, 0.0)
      call closepoly()
      call color(D_MAGENTA)
   ! draw a sector representing a 1/4 circle
      call sector(1.5, -7.0, 3.0, 0.0, 90.0)
      idum=getkey()
   end subroutine drawpoly
<br />   end program demo_poly
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c256"><img src="../images/poly.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c259">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>poly2(3f)</b> - [M_draw:POLYGONS] Construct an (x, y) polygon from an array of points <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>poly2</b>(<i>n</i>, <i>points</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>n</i>
<b>real,intent</b>(<i>in</i>) :: <b>points</b>(<i>2</i>, <i>n</i>)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Construct an (x, y) polygon from an array of <i>points</i> provided by the user.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_poly2
   use M_draw
   integer :: i,j
   real    :: xx,yy
      call prefsize(512,512)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call ortho2(0.0,256.0,0.0,256.0)
      call linewidth(1)
      call polyfill(.true.)
      ! step thru a series of rectangular cells
      icolor=0
      xx=0.0
      do i=1,16
         yy=0.0
         do j=1,16
            yy=yy+16.0
            icolor=icolor+1
            call setcolor(icolor,xx,yy)
         enddo
         xx=xx+16.0
      enddo
      ipaws=getkey()
      call vexit()
   contains
<br />   subroutine setcolor(iset,xx,yy)
   use M_strings, only : v2s
   use M_color,  only : color_name2rgb
   integer,intent(in) :: iset
   real,intent(in)    :: xx,yy
   character(len=80)  :: echoname
   real    :: points(2,100)
   if(iset.gt.255)return
   ! determine coordinates of next square
   points(1:2,1)=[xx,      yy      ]
   points(1:2,2)=[xx,      yy+16.0 ]
   points(1:2,3)=[xx+16.0, yy+16.0 ]
   points(1:2,4)=[xx+16.0, yy      ]
   points(1:2,5)=[xx,      yy      ]
   ! get some nice RGB values to try from named colors known by M_color module
   call color_name2rgb(v2s(icolor),red,green,blue,echoname)
   if(echoname.eq.'Unknown') return
   ! set a color number to the new RGB values
   write(*,*)icolor, nint(red*2.55), nint(green*2.55), nint(blue*2.55),trim(echoname)
   call mapcolor(icolor, nint(red*2.55), nint(green*2.55), nint(blue*2.55))
   ! set to the new color
   call color(icolor)
   ! fill the rectangle in that color
   call poly2(5,points)
   end subroutine setcolor
<br />   end program demo_poly2
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c259"><img src="../images/poly2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c262">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>polyfill(3f)</b> - [M_draw:POLYGONS] Set the polygon fill flag <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>polyfill</b>(<i>onoff</i>)
logical <i>onoff</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set the polygon fill flag. This will always turn off hatching. A non-zero integer or LOGICAL .true. turns polyfill on.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_polyfill
   ! Using polygons, hatching, and filling.
      use M_draw, only : vinit, color, clear, ortho, boxtext, vexit
      use M_draw, only : polyfill
      use M_draw,    only  : D_BLACK,   D_WHITE
      use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
      use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
      integer           :: ios
      character(len=50) :: device
      print*,'Enter output device:'
      read(*,'(a)',iostat=ios)device
      if(ios.ne.0)device=' '
      call vinit(device)
   ! clear to black
      call color(D_BLACK)
      call clear()
   ! world coordinates are now in the range -10 to 10
   ! in x, y, and z. Note that positive z is towards us.
      call ortho(-10.0, 10.0, -10.0, 10.0, 10.0, -10.0)
      call color(D_YELLOW)
   ! write out the string "Polygon from poly()" in the
   ! starting at (-8.0, -4.0) and scaled to be 4.0 units long,
   ! 0.5 units high.
      call boxtext(-8.0, -4.0, 4.0, 0.5, 'Polygon from poly()')
      call color(D_GREEN)
   ! write out a scaled string starting at (0.0, 6.0)
      call boxtext(0.0, 6.0, 4.0, 0.5, 'Polygon from move()/ draw()')
      call color(D_MAGENTA)
   ! write out a scaled string starting at (0.0, 6.0)
      call boxtext(3.5, -3.5, 1.9, 0.5, 'Sector')
   ! turn on polygon filling - this automatically turns off hatching
      call polyfill(.true.)
   ! draw some polygons with filling
      call my_drawpoly()
      call vexit()
   contains
   subroutine my_drawpoly()
      use M_draw, only : color, move, draw, closepoly, sector, getkey
      use M_draw, only : poly, closepoly, sector, makepoly
      use M_draw,    only  : D_BLACK,   D_WHITE
      use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
      use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
<br />      real parray(3,4)                   ! An array of points for a polygon
      data parray/ -8.0, -8.0, 0.0,  &amp;
      &amp; -5.0, -8.0, 0.0,  &amp;
      &amp; -5.0, -5.0, 0.0,  &amp;
      &amp; -8.0, -5.0, 0.0 /
      call color(D_YELLOW)
   ! Draw a polygon using poly, parray is our array of
   ! points and 4 is the number of points in it.
      call poly(4, parray)
      call color(D_GREEN)
   ! Draw a 5 sided figure by using move, draw and closepoly.
      call makepoly()
      call move(0.0, 0.0, 0.0)
      call draw(3.0, 0.0, 0.0)
      call draw(3.0, 4.0, 0.0)
      call draw(-1.0, 5.0, 0.0)
      call draw(-2.0, 2.0, 0.0)
      call closepoly()
      call color(D_MAGENTA)
   ! draw a sector representing a 1/4 circle
      call sector(1.5, -7.0, 3.0, 0.0, 90.0)
      idum=getkey()
   end subroutine my_drawpoly
   end program demo_polyfill
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c262"><img src="../images/polyfill.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c265">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>polyhatch(3f)</b> - [M_draw:POLYGONS] Set the polygon hatch flag <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>polyhatch</b>(<i>onoff</i>)
logical <i>onoff</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the polygon hatch flag. This will always turn off fill. A non-zero integer or LOGICAL .true. turns polyhatch on. Note that hatched polygons
        must initially be defined parallel to the X-Y plane.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_polyhatch
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   real :: N=11
   call prefsize(600*10/6,200*10/6)
   call vinit(' ')
   call page( -15.0, 15.0, -5.0, 5.0)
   call linewidth(100)
   call color(D_BLACK)
   call clear()
   call color(D_RED)
   call spirograph(-10.0, 0.0, N, 1.0, N, 5.0, 1000, 0.0, 0.0, 0)
   call polyhatch(.true.) ! turn on polygon hatching
   call hatchang(45.0)
   call hatchpitch(0.3)
   call color(D_GREEN)
   call spirograph(10.0, 0.0, N, 1.0, N, 5.0, 1000, 0.0, 0.0, 2)
   call vflush()
   key=getkey()
   call vexit()
   end program demo_polyhatch
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c265"><img src="../images/polyhatch.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c275">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>popattributes(3f)</b> - [M_draw:ATTRIBUTE_STACK] Restore attributes to what they were at last <b>pushattributes</b>(). <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>popattributes</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Restore the attributes to what they were at the last <b>pushattributes</b>().</p>
      </blockquote>
      <hr />
      <br />
      <div class="c275"><img src="../images/popattributes.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c278">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>popdev(3f)</b> - [M_draw:DEVICE] pop device from stack created by pushdev. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>popdev</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Pops a device off the device stack and reinstates the previously pushed device.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c278"><img src="../images/popdev.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c281">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>popmatrix(3f)</b> - [M_draw:MATRIX_STACK] Reinstall the last matrix pushed <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>popmatrix</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Retrieve the last matrix pushed and make it the current transformation matrix.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c281"><img src="../images/popmatrix.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c284">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>popviewport(3f)</b> - [M_draw:VIEWPORT] Retrieve last viewport <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>popviewport</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Retrieve last viewport.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c284"><img src="../images/popviewport.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c287">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>prefposition(3f)</b> - [M_draw:WINDOW_SETUP] Specify preferred position of window <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>prefposition</b>(<i>x</i>, <i>y</i>)
<br />    integer,intent(in) :: x, y
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Specify the preferred position of the window opened by the *next* vinit in raster units or units of resolution, depending on the output device. The
        physical size of the units are generally device-specific -- For X11 Windows and PPM pixmaps the values would represent rasters. For vector output
        devices the number of "rasters" per inch varies.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_prefposition
     use M_draw, only    : prefsize, vinit, ortho2, clear, getkey, prefposition
     use M_draw, only    : move2, draw2, vexit, color
     use M_draw,    only  : D_BLACK,   D_WHITE
     use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
     use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
     implicit none
     integer :: ipaws
<br />     call prefsize(60,40)
     call prefposition(100,100)
<br />     call vinit(' ')         ! start graphics using device $M_DRAW_DEVICEDEVICE
     call ortho2(-300.0,300.0,-200.0,200.0)
     call color(D_BLACK)
     call clear()
     call color(D_RED)
     call move2(-300.0,-200.0)
     call draw2(300.0,200.0)
     call move2(300.0,-200.0)
     call draw2(-300.0,200.0)
     ipaws=getkey()
     call vexit()
<br />     end program demo_prefposition
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c287"><img src="../images/prefposition.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c290">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>prefsize(3f)</b> - [M_draw:WINDOW_SETUP] Specify preferred width and height of window in physical units <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>prefsize</b>(<i>width</i>, <i>height</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>width</i>, <i>height</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Specify the preferred <i>width</i> and <i>height</i> of the device output surface opened by the *next* <b>vinit</b>(3f).</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c291" width="6%" nowrap="nowrap">WIDTH</td>
            <td valign="bottom"><i>width</i> of device to create when <b>vinit</b>(3f) is called</td>
          </tr>
          <tr valign="top">
            <td class="c291" width="6%" nowrap="nowrap">HEIGHT</td>
            <td valign="bottom"><i>height</i> of device to create when <b>vinit</b>(3f) is called</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_prefsize
     use M_draw, only: prefsize, vinit, ortho2, clear, getkey
     use M_draw, only: move2, draw2, vexit, color
     use M_draw,    only  : D_BLACK,   D_WHITE
     use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
     use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
     implicit none
     integer :: ipaws
        ! make first file with one size
        call prefsize(60*2,40*2)
        call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
        call picture()
        ipaws=getkey()
        call vexit()
<br />        ! make second file with another size
        call prefsize(60*3,40*3)
        call vinit(' ')
        call picture()
        ipaws=getkey()
        call vexit()
     contains
     subroutine picture
        call ortho2(-300.0,300.0,-200.0,200.0)
        call color(D_BLACK)
        call clear()
        call color(D_RED)
        call move2(-300.0,-200.0)
        call draw2(300.0,200.0)
        call move2(300.0,-200.0)
        call draw2(-300.0,200.0)
     end subroutine picture
     end program demo_prefsize
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c290"><img src="../images/prefsize.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c297">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>pushattributes(3f)</b> - [M_draw:ATTRIBUTE_STACK] Save the current attributes on the attribute stack. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>pushattributes</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Save the current attributes on the attribute stack.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c297"><img src="../images/pushattributes.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c300">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>pushdev(3f)</b> - [M_draw:DEVICE] push current device onto a stack <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>pushdev</b>(<i>device</i>)
character *(*) <i>device</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Initialize a new <i>device</i> without changing attributes, viewport etc, but save the previously initialised <i>device</i> on a stack.
        <p>Note, this is intended to completely change the <i>device</i>, it will not work if you <b>pushdev</b>() the same <i>device</i> that you are
        already running. (This will be fixed at a later date).</p>
      </blockquote>
      <hr />
      <br />
      <div class="c300"><img src="../images/pushdev.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c303">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>pushmatrix(3f)</b> - [M_draw:MATRIX_STACK] Save the current transformation matrix on the matrix stack. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>pushmatrix</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Save the current transformation matrix on the matrix stack.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c303"><img src="../images/pushmatrix.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c306">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>pushviewport(3f)</b> - [M_draw:VIEWPORT] Save current viewport <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>pushviewport</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Save current viewport.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c306"><img src="../images/pushviewport.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c309">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rcurve(3f)</b> - [M_draw:CURVE] Draw a rational curve. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rcurve</b>(<i>geom</i>)
real <i>geom</i>(4,4)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw a rational curve.
      </blockquote>
      <hr />
      <br />
      <div class="c309"><img src="../images/rcurve.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c312">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rdraw(3f)</b> - [M_draw:DRAW] Relative draw <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rdraw</b>(<i>deltax</i>, <i>deltay</i>, <i>deltaz</i>)
real <i>deltax</i>, <i>deltay</i>, <i>deltaz</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Relative draw. <i>deltax</i>, <i>deltay</i>, and <i>deltaz</i> are offsets in world units.
      </blockquote>
      <hr />
      <br />
      <div class="c312"><img src="../images/rdraw.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c315">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rdraw2(3f)</b> - [M_draw:DRAW] Relative draw from current position to given point <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rdraw2</b>(<i>deltax</i>, <i>deltay</i>)
<b>real,intent</b>(<i>in</i>) :: <i>deltax</i>, <i>deltay</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Relative draw from current position to specified point using current color and line width. Updates current position to new point. (x, y) is a point
        <i>in</i> world coordinates.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <i>deltax</i> and <i>deltay</i> are offsets <i>in</i> world units.
        <table cellpadding="3">
          <!-- tsb: <I>deltax</I> and <I>deltay</I> are offsets <I>in</I> world units.
 -->
          <tr valign="top">
            <td class="c316" width="6%" nowrap="nowrap">X</td>
            <td valign="bottom">new X position</td>
          </tr>
          <tr valign="top">
            <td class="c316" width="6%" nowrap="nowrap">Y</td>
            <td valign="bottom">new Y position</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_rdraw2
     use M_draw, only: vinit, prefsize, ortho2,linewidth,getkey
     use M_draw, only: clear, move2, rdraw2, vexit,color
     use M_draw,    only  : D_BLACK,   D_WHITE
     use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
     use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
     integer :: ipaws
<br />     call prefsize(200,200)
     call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
     call ortho2(-55.0, 55.0, -55.0, 55.0)
     call linewidth(400)
     call color(D_WHITE)
     call clear()
<br />     call color(D_RED)
     call move2(-50.0,0.0)
     call square(50.0)
<br />     call linewidth(200)
     call color(D_GREEN)
     call move2(  0.0,-50.0)
     call square(50.0)
<br />     ipaws=getkey()
     call vexit()
<br />     contains
<br />     subroutine square(side)
     call rdraw2( side,   0.0)
     call rdraw2(  0.0,  side)
     call rdraw2(-side,   0.0)
     call rdraw2(  0.0, -side)
     end subroutine square
<br />     end program demo_rdraw2
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c315"><img src="../images/rdraw2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c319">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rect(3f)</b> - [M_draw:POLYGONS] Draw a rectangle given two corners <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rect</b>(<i>x1</i>, <i>y1</i>, <i>x2</i>, <i>y2</i>)
<b>real,intent</b>(<i>in</i>) :: <i>x1</i>,<i>y1</i>,<i>x2</i>,<i>y2</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw rectangle given two opposite corners.
        <p>Note: rectangles are regarded as polygons, so if polyfill or polyhatch has been called with .TRUE., the rectangle will be filled or hatched
        accordingly.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        Given
        <pre>
      x1,y1 ############ x2,y1
            #          #
            #          #
            #          #
      x1,y2 ############ x2,y2
<br />
</pre>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c320" width="6%" nowrap="nowrap">X1,Y1</td>
              <td valign="bottom">coordinates of a corner of the rectangle</td>
            </tr>
            <tr valign="top">
              <td class="c320" width="6%" nowrap="nowrap">X2,Y2</td>
              <td valign="bottom">coordinates of corner point opposite first point</td>
            </tr>
          </table>
        </blockquote>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_rect
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   implicit none
   integer :: ipaws
   real    :: b=0.2
<br />   !! set up graphics area
   call prefsize(1000,200)
   call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
   call page(-25.0-b, 25.0+b, -5.0-b, 5.0+b)
<br />   call linewidth(150)
   call color(D_RED)
   call rect(-24.0, -4.0, -12.0, 4.0)
   call polyfill(.true.)
   call color(D_GREEN)
   call rect(-10.0, -4.0, -2.0, 4.0)
   call polyhatch(.true.)
   call hatchpitch(0.4)
   call hatchang(30.0)
   call linewidth(20)
   call color(D_BLUE)
   call rect(0.0, -4.0, 20.0, 3.0)
   call linewidth(200)
   call color(D_BLUE)
   call move2(-25.0, -5.0)
   call draw2(-25.0, 5.0)
   call draw2(25.0, 5.0)
   call draw2(25.0, -5.0)
   call draw2(-25.0, -5.0)
<br />   !! pause
   call vflush()
   ipaws=getkey()
<br />   !! wrap up graphics
   call vexit()
<br />   end program demo_rect
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c319"><img src="../images/rect.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c323">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rightjustify(3f)</b> - [M_draw:TEXT] right justify text <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rightjustify</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Right justifies text. The text string will begin at a point to the notional left of the current position and finish at the current position. Left
        justification and X centering are turned off.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_rightjustify
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   implicit none
   real    :: x1, x2, y1, y2
   real    :: scl, ax, bx
   integer :: key
      call prefsize(1200,120)
      call vinit(' ')
      x1=0; x2=40; y1=0; y2=4; scl=1.9
      call page(x1,x2,y1,y2)
      call textsize(0.9*scl,1.4*scl)
      call font("times.rb")
      call linewidth(200)
      AX=(x1+x2)/2+6; BX=y1+1.3
      call move2(AX,BX)
      call rightjustify()
      call color(D_GREEN)
      call drawstr("rightjustify()")
      call color(D_RED)
      call move2(AX-1.0,BX)
      call draw2(AX+1.0,BX)
      call move2(AX,BX-1.0)
      call draw2(AX,BX+1.0)
      call vflush()
      key=getkey()
      call vexit()
   end program demo_rightjustify
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c323"><img src="../images/rightjustify.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c326">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rmove(3f)</b> - [M_draw:MOVE] Relative move <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rmove</b>(<i>deltax</i>, <i>deltay</i>, <i>deltaz</i>)
real <i>deltax</i>, <i>deltay</i>, <i>deltaz</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Relative move. <i>deltax</i>, <i>deltay</i>, and <i>deltaz</i> are offsets in world units.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c326"><img src="../images/rmove.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c329">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rmove2(3f)</b> - [M_draw:MOVE] Relative move in world units. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rmove2</b>(<i>deltax</i>, <i>deltay</i>)
<b>real,intent</b>(<i>in</i>) :: <i>deltax</i>, <i>deltay</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Update current position. Relative move2. <i>deltax</i> and <i>deltay</i> are offsets <i>in</i> world units.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c330" width="6%" nowrap="nowrap">X</td>
            <td valign="bottom">new X position</td>
          </tr>
          <tr valign="top">
            <td class="c330" width="6%" nowrap="nowrap">Y</td>
            <td valign="bottom">new Y position</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_rmove2
     use M_draw, only: prefsize, vinit, ortho2, clear, getkey
     use M_draw, only: move2, rmove2, rdraw2, vexit
     use M_draw, only: linewidth
     call prefsize(500,500)
     call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
     call ortho2(-110.0,110.0,-110.0,110.0)
     call move2(-100.0,-100.0)
     call linewidth(70)
     do i=1,20
        call rmove2(10.0, 0.0)
        call rdraw2( 0.0,10.0)
     enddo
     ipaws=getkey()
     call vexit()
     end program demo_rmove2
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c329"><img src="../images/rmove2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c1">
      </div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>rotate(3f)</b> - [M_draw:TRANSFORMATION] Set up a rotation in axis axis where axis is one of 'x','y', or 'z'.
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>rotate</b>(<i>angle</i>, <i>axis</i>)
real <i>angle</i>
character <i>axis</i>
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>Set up a rotation of coordinate system along specified <i>axis</i>, relative to current coordinate system.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">angle</td>

            <td valign="bottom">Angle in degrees to rotate coordinate system, with clockwise angles being positive.</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">axis</td>

            <td valign="bottom">Which <i>axis</i> to perform rotation about. Allowed values are 'x',</td>
          </tr>

        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample usage
        <pre>
   program demo_rotate
   use M_drawplus, only : draw_interpret
   character(len=:),allocatable :: draw_cmds(:)
   draw_cmds=[ character(len=128) ::                                      &amp;
   '# set up display                                                    ',&amp;
   'prefsize 300 300;prefposition 200 10;vinit X11;                     ',&amp;
   'set SIZE=1.2                                                        ',&amp;
   'color 3;clear;color 2; ortho2 -SIZE SIZE -SIZE SIZE                 ',&amp;
   'set X=-0.75 Y=0.75                                                  ',&amp;
   '# create an object to repeatedly draw                               ',&amp;
   'makeobj 1                                                           ',&amp;
   'polyfill .true.;color 1; rect 0 0 X Y                               ',&amp;
   'polyfill .false.;linewidth 200;color 2 ;rect 0 0 X Y                ',&amp;
   'closeobj                                                            ',&amp;
   '# draw opbject, rotating coordinate system between instantiations   ',&amp;
   'callobj 1                                                           ',&amp;
   'rotate 45 z                                                         ',&amp;
   'callobj 1                                                           ',&amp;
   'rotate 45 z                                                         ',&amp;
   'callobj 1                                                           ',&amp;
   'circle 0 0 X/3                                                      ',&amp;
   'getkey;vexit                                                        ']
   write(*,'(a)')draw_cmds
   call draw_interpret(draw_cmds,delimiters=';')
   end program demo_rotate
<br />
</pre>
      </blockquote><a name="5"></a>

      <h3><a name="5">SEE ALSO</a></h3>

      <blockquote>
        translate, pushmatrix, popmatrix, scale
      </blockquote>
      <hr />
      <div class="c1"><img src="../images/rotate.gif" /></div>
    </div>
  </div>
</div>
</html>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c337">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rpatch(3f)</b> - [M_draw:PATCH] Draws a rational patch in the current basis, according to the geometry matrices gx, gy, gz, and gw.
        <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rpatch</b>(<i>gx</i>, <i>gy</i>, <i>gz</i>, <i>gw</i>)
<b>real,intent</b>(<i>in</i>) :: <i>gx</i>(4,4), <b>gy</b>(4,4), <i>gz</i>(4,4), <b>gw</b>(4,4)
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Draws a rational patch <i>in</i> the current basis, according to the geometry matrices <i>gx</i>, <i>gy</i>, <i>gz</i>, and <i>gw</i>.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c337"><img src="../images/rpatch.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c340">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rsdraw2(3f)</b> - [M_draw:DRAW] Relative draw in screen units (<b>-1.0</b> to 1.0). <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rsdraw2</b>(<i>deltax</i>, <i>deltay</i>)
real <i>deltax</i>, <i>deltay</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Relative sdraw2. delatx and <i>deltay</i> are in screen units (<b>-1.0</b> to 1.0).
      </blockquote>
      <hr />
      <br />
      <div class="c340"><img src="../images/rsdraw2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c343">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>rsmove2(3f)</b> - [M_draw:MOVE] Relative move in screen units (<b>-1.0</b> to 1.0). <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>rsmove2</b>(<i>deltax</i>, <i>deltay</i>)
real <i>deltax</i>, <i>deltay</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Relative smove2. <i>deltax</i>, and <i>deltay</i> are offsets in screen units (<b>-1.0</b> to 1.0).</p>
      </blockquote>
      <hr />
      <br />
      <div class="c343"><img src="../images/rsmove2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c346">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>saveobj(3f)</b> - [M_draw:OBJECT] Save object number n into file filename. Does NOT save objects called inside object n. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>saveobj</b>(<i>n</i>, <i>filename</i>)
<b>integer,intent</b>(<i>in</i>) :: <i>n</i>
<b>character</b>(len=*),intent(<i>in</i>) :: <i>filename</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Save the object number <i>n</i> into the file <i>filename</i>. This call does not save objects called inside object <i>n</i>.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_saveobj
   ! create object in file "circle.obj" for use with loadobj(3f)
   use M_draw
   use M_drawplus, only : invokeobj, pop, push
   implicit none
   character(len=:),allocatable :: env
   integer :: ipaws
   integer :: env_len
      call voutput('+')            ! ignore $M_DRAW_OUTPUT
      call vinit('nil')            ! start graphics
      call push()
      !
      call makeobj(3)              ! create an object
         call polyfill(.true.)
         call color(D_GREEN)
         call circle(0.0,0.0,10.0)
         call polyfill(.false.)
         call color(D_BLUE)
         call linewidth(100)
         call circle(0.0,0.0,4.0)
      call closeobj()
      !
      call saveobj(3,"circle.obj") ! save object to file
      call pop()
      call vexit()                 ! exit graphics
      !
      !-------  now this could be a separate program to use object
      !
      !------------------------------------------------------------
      ! CURRENTLY:
      ! with multiple vinit(3f) calls the environment variable is
      ! not used without explicitly using it
      call get_environment_variable('M_DRAW_OUTPUT',LENGTH=env_len)
      if(env_len.ne.0)then
         allocate(character(len=env_len) :: env)
         call get_environment_variable('M_DRAW_OUTPUT',env)
         call voutput(env)
      endif
      !------------------------------------------------------------
      call vinit(' ')  ! set up device
      call page(-100.0,100.0,-100.0,100.0)
      call loadobj(100,"circle.obj")
      ! translate x,y,z scale x,y,z rotate x,y,z object
      call invokeobj(   0.0,  0.0, 0.0,1.0,1.0,1.0,0.0,0.0,0.0, 100)
      call invokeobj( -20.0,-20.0, 0.0,1.0,2.0,1.0,0.0,0.0,0.0, 100)
      call invokeobj(  30.0, 40.0, 0.0,2.0,2.0,1.0,0.0,0.0,0.0, 100)
      ipaws=getkey()
      call vexit() ! set the screen back to its original state
      !
   end program demo_saveobj
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c346"><img src="../images/saveobj.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c349">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>scale(3f)</b> - [M_draw:TRANSFORMATION] Set up scaling factors in x, y, and z axis. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="6">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>scale</b>(<i>x</i>, <i>y</i>, <i>z</i>)
<br />    real,intent(in) ::  x, y, z
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set up scaling factors in <i>x</i>, <i>y</i>, and <i>z</i> axis. The scaling is applied relative to the current transformation matrix; ie. the
        scaling is accumulative.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c350" width="6%" nowrap="nowrap">x</td>
            <td valign="bottom">scaling factor to apply in X direction to current transformation matrix</td>
          </tr>
          <tr valign="top">
            <td class="c350" width="6%" nowrap="nowrap">y</td>
            <td valign="bottom">scaling factor to apply in Y direction to current transformation matrix</td>
          </tr>
          <tr valign="top">
            <td class="c350" width="6%" nowrap="nowrap">x</td>
            <td valign="bottom">scaling factor to apply in Z direction to current transformation matrix</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program
        <pre>
   program demo_scale
   use M_drawplus, only : draw_interpret
   character(len=:),allocatable :: draw_cmds(:)
   draw_cmds=[ character(len=128) ::                                      &amp;
   '# set up display                                                    ',&amp;
   'prefsize 300 300;prefposition 200 10;vinit X11;                     ',&amp;
   'set SIZE=1.2                                                        ',&amp;
   'color 3;clear;color 2; ortho2 -SIZE SIZE -SIZE SIZE                 ',&amp;
   'set X=-0.75 Y=0.75                                                  ',&amp;
   '# create an object to repeatedly draw                               ',&amp;
   'makeobj 1                                                           ',&amp;
   'polyfill .true.;color 1; rect 0 0 X Y                               ',&amp;
   'polyfill .false.;linewidth 200;color 2 ;rect 0 0 X Y                ',&amp;
   'closeobj                                                            ',&amp;
   '# draw opbject, rotating coordinate system between instantiations   ',&amp;
   'pushmatrix                                                          ',&amp;
   'scale 1.1 2.0                                                       ',&amp;
   'callobj 1                                                           ',&amp;
   'scale 0.5 0.5                                                       ',&amp;
   'callobj 1                                                           ',&amp;
   'circle 0 0 X/3                                                      ',&amp;
   'popmatrix                                                           ',&amp;
   'color 5;circle 0 0 X/3                                              ',&amp;
   'getkey;vexit                                                        ']
   write(*,'(a)')draw_cmds
   call draw_interpret(draw_cmds,delimiters=';')
   end program demo_scale
<br />
</pre>
      </blockquote><a name="5"></a>
      <h3><a name="5">SEE ALSO</a></h3>
      <blockquote>
        rotate, translate, pushmatrix, popmatrix
      </blockquote>
      <hr />
      <br />
      <div class="c349"><img src="../images/scale.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c352">
        <hr />
        <h1><i>Manual Reference Pages -</i> sdraw2 (3)</h1>
        <hr />
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>sdraw2(3f)</b> - [M_draw:DRAW] Draw in screen coordinates (<b>-1.0</b> to 1.0). <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3>CONTENTS</h3>
      <blockquote>
        <a href="#1">Synopsis</a><br />
        <a href="#2">Description</a><br />
      </blockquote><a name="3"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>sdraw2</b>(<i>x</i>, <i>y</i>)
real <i>x</i>, <i>y</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Draw in screen coordinates (<b>-1.0</b> to 1.0).
      </blockquote>
      <hr />
      <br />
      <div class="c352"><img src="../images/sdraw2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c355">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>sector(3f)</b> - [M_draw:ARCS] Draw a sector. Note: sectors are polygons. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>sector</b>(<i>x</i>, <i>y</i>, <i>radius</i>, <i>startang</i>, <i>endang</i>)
REAL <i>x</i>, <i>y</i>, <i>radius</i>, <i>startang</i>, <i>endang</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Draw a sector. <i>x</i>, <i>y</i>, and <i>radius</i> are values in world units. Note: sectors are regarded as polygons, so if polyfill or
        polyhatch has been called with 1, the sectors will be filled or hatched accordingly.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_sector
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   implicit none
   real           :: b=0.5
   real           :: R=4.9
   real           :: X, Y, A
   integer        :: key
      call prefsize(1000,200)
      call vinit(' ')
      call color(D_BLACK)
      call clear()
      call color(D_YELLOW)
      call page(-25.0-b, 25.0+b, -5.0-b, 5.0+b)
      call textsize(1.0,1.4)
      call font("futura.l")
      call centertext(.true.)
<br />      ! draw sectors with various start and end angles
<br />      call linewidth(150)
      call color(D_WHITE)
      X=-20; Y=0; R=5.0; A=0; B=30
      call sector(X,Y,R,A,B)
      call move2(X, 4.0)
      call linewidth(50)
      call drawstr("0 to 30 deg.")
<br />      call linewidth(150)
      call color(D_RED)
      X=-10; Y=0; R=5; A=0; B=-45
      call sector(X,Y,R,A,B)
      call move2(X,-4.0)
      call linewidth(50)
      call drawstr("0 to -45 deg.")
<br />      call polyfill(.true.)
<br />      call linewidth(150)
      call color(D_GREEN)
      X=-0; Y=0; R=5; A=100; B=200
      call sector(X,Y,R,A,B)
      call move2(X,-4.0)
      call linewidth(50)
      call drawstr("100 to 200 deg.")
<br />      call polyhatch(.true.)
      call hatchpitch(1.0/2.0)
      call hatchang(90.0)
<br />      call linewidth(150)
      call color(D_MAGENTA)
      X=10; Y=0; R=5; A=-30; B=30
      call sector(X,Y,R,A,B)
      call move2(X,-4.0)
      call linewidth(50)
      call drawstr("-30 to 30 deg.")
<br />      call hatchang(30.0)
      call linewidth(150)
      call color(D_CYAN)
      X=20; Y=0; R=5; A=45; B=-45
      call sector(X,Y,R,A,B)
      call move2(X, 4.0)
      call linewidth(50)
      call drawstr(" 45 to -45 deg.")
<br />      key=getkey()
      call vexit()
   end program demo_sector
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c355"><img src="../images/sector.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c361">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>sgetgp2(3f)</b> - [M_draw:POSITION] Gets the current screen graphics position in screen coords (<b>-1</b> to 1) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>sgetgp2</b>(<i>x</i>, <i>y</i>)
real <i>x</i>, <i>y</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Gets the current screen graphics position in screen coords (<b>-1</b> to 1)
      </blockquote>
      <hr />
      <br />
      <div class="c361"><img src="../images/sgetgp2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c364">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>slocator(3f)</b> - [M_draw:INTERACTIVE] Find out where cursor is in screen coordinates <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
integer function <b>slocator</b>(<i>xaddr</i>, <i>yaddr</i>)
real <i>xaddr</i>, <i>yaddr</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Find out where the cursor is. <i>xaddr</i> and <i>yaddr</i> are set to the current location in screen coordinates. The return value of the
        function is set up in the same way as with locator. If the device has no locator device slocator returns <b>-1</b>.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    !
    !      a routine to demonstrate using locator.
    !
    program demo_slocator
<br />    use M_draw
<br />    character(len=20) :: dev
    integer bt
    real x, y, sx, sy
    logical act, curpnt
    integer :: ios
<br />    print*,'Enter device name:'
    read(*,'(a)',iostat=ios) dev
    if(ios.ne.0)dev=' '
    call vinit(dev)
<br />    call color(D_BLACK)
    call clear()
<br />    call color(D_BLUE)
    !
    !       draw some axes
    !
    call move2(0.0, 1.0)
    call draw2(0.0, -1.0)
<br />    call move2(1.0, 0.0)
    call draw2(-1.0, 0.0)
<br />    call color(D_GREEN)
<br />    act = .false.
    curpnt = .false.
    !
    !       locator returns whether a mouse button has been
    !       pressed or not. In a device such as the tektronix
    !       where you have to wait for a keypress to get the
    !       position of the crosshairs locator returns 0
    !       automatically on every second call. A return value
    !       of 2 indicates the second mouse button has been pressed.
    !       A return value of 1 indicates the first mouse button has
    !       been pressed. We wait for the locator to return zero so
    !       that we know the mouse button has been released.
    !
    write(*,*)' click two points to create a line segment'
    write(*,*)' button 2 exits'
<br />    INFINITE: do
       bt = slocator(x, y)
       !! write(*,*)'slocator returned ',bt,' and coordinates ',x,y
       if (bt .eq. -1) then
          call vexit()
          print*,'No locator device found'
          stop
       elseif (bt .eq. 2) then
          call vexit()
          stop
       elseif (bt .eq. 0) then
          act = .true.
       elseif (act) then
          act = .false.
          if (bt .eq. 1) then
             if (curpnt) then
                call move2(sx, sy)
                call draw2(x, y)
                curpnt = .false.
             else
                curpnt = .true.
             endif
<br />             sx = x
             sy = y
          endif
       endif
    enddo INFINITE
<br />    end program demo_slocator
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c364"><img src="../images/slocator.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c367">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>smove2(3f)</b> - [M_draw:MOVE] Move current graphics position in screen coordinates (<b>-1.0</b> to 1.0). <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>smove2</b>(<i>x</i>, <i>y</i>)
real <i>x</i>, <i>y</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Move current graphics position in screen coordinates (<b>-1.0</b> to 1.0).
      </blockquote>
      <hr />
      <br />
      <div class="c367"><img src="../images/smove2.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>strlength(3f)</b> - [M_draw:TEXT] return length of string <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
<br /><b>real</b> <i>function</i> <b>strlength</b>(string)
<b>character</b>(len=*),intent(in) :: <i>string</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Return the length of the <i>string</i> "STRING" in world units.
      </blockquote><a name="3"></a>
      <h3><a name="3">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c375" colspan="1">STRLENGTH</td>
            <td>length of <i>string</i> using current font size</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample Program:
        <pre>
   program demo_strlength
   use :: M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   real    :: left
   real    :: baseline
   integer :: icolor=0
   real    :: texth=10.0
      !! set up drawing surface
      call prefsize(800, 400)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call page(-100.0, 300.0, -100.0, 100.0)
      call color(D_WHITE)
      call clear()
      call linewidth(40)
      call textsize(texth, texth)
      call xcentertext()
      call color(D_RED)
<br />      baseline=85.0
      call move2(0.0,baseline)
      call drawstr('If I Can Stop One Heart')
      baseline= baseline-texth*1.20
      call move2(0.0,baseline)
      call drawstr('by Emily Dickinson')
      call centertext(.false.)
<br />      texth=8.5
      baseline=baseline-texth*1.50
      call textsize(texth, texth)
      left=-90.0
<br />      call nextline('If I can stop one heart from breaking,')
      call nextline('I shall not live in vain;')
      call nextline('If I can ease one life the aching,')
      call nextline('Or cool one pain,')
      call nextline('Or help one fainting robin')
      call nextline('Unto his nest again,')
      call nextline('I shall not live in vain.')
<br />      ipaws=getkey()
      call vexit()
   contains
   subroutine nextline(string)
   character(len=*) :: string
   real :: xx
   !! reduce some duplicate code; very specific to this EXAMPLE
      call color(icolor)
      baseline=baseline-texth*1.5    ! move down before drawing line
         call polyfill(.true.)
            call makepoly()
               xx=strlength(string)
               call rect(left,baseline-texth*0.3,left+xx,baseline+texth)
            call closepoly()
         call polyfill(.false.)
      call color(D_WHITE)
      call move2(left, baseline)
      call drawstr(string)    ! draw string
      icolor=icolor+1         ! set pen color
   end subroutine nextline
<br />   end program demo_strlength
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c374"><img src="../images/strlength.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c378">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>swapbuffers(3f)</b> - [M_draw:DOUBLE_BUFFERING] Swap the front and back buffers. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>swapbuffers</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Swap the front and back buffers.
      </blockquote>
      <hr />
      <br />
      <div class="c378"><img src="../images/swapbuffers.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c381">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>textang(3f)</b> - [M_draw:TEXT] Set the SOFTWARE text angle. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>textang</b>(<i>ang</i>)
<b>real,intent</b>(<i>in</i>) :: <i>ang</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set the text angle. This angles strings and chars. This routine only affects software text. Angle is <i>in</i> degrees
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c382" width="6%" nowrap="nowrap">ANG</td>
            <td valign="bottom">The angle <i>in</i> degrees to draw text with when using <b>drawstr</b>(3f). Angles are measured counterclockwise with zero
            degrees at the horizontal line to the right of the original.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_textang
   use :: M_draw
   use :: M_units, only : cosd, sind
<br />   !! set up drawing environment
   call prefsize(600,600)
   call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
   call ortho2(-100.0,100.0,-100.0,100.0)
   call textsize(7.0,7.0)
   call linewidth(20)
   call color(D_BLACK)
   call clear()
<br />   do i=1,30
      !! draw radial lines
      call color(D_RED)
      call move2(0.0,0.0)
      call draw2(100.0*cosd(i*12),100.0*sind(i*12))
      !! draw rotated text
      call color(D_WHITE)
      call move2(30.0*cosd(i*12),30.0*sind(i*12))
      call textang(i*12.0)
      call drawstr('angled text')
   enddo
<br />   ipaws=getkey()
<br />   call vexit()
<br />   end program demo_textang
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c381"><img src="../images/textang.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c385">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>textjustify(3f)</b> - [M_draw:TEXT] general text justification (C only) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>textjustify</b>(<i>val</i>)
<b>character</b>(kind=c_short) :: ival
<b>character</b>(kind=c_char) :: <i>val</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        General (direct) control of text justification. The value of <i>val</i> is made up of the logical OR of the following predefined constants in draw.h
        (FOR C and Fortran only). D_LEFT, D_RIGHT, D_XCENTERED, D_TOP, D_BOTTOM, D_YCENTERED. Centering takes priority, as does RIGHT and TOP justification
        (if you were silly enough to set it to D_LEFT|D_RIGHT for EXAMPLE that is). A value of 0 (zero) (in all languages) resets the textjustification to
        the default.
        <pre>
       ! from Fortran, use IANY() to OR the array of options, and CHAR()
       ! to convert the integer result to a C_CHAR type. KIND C_CHAR is
       ! defined by loading a the intrinsic module for C bindings ("USE ISO_C_BINDING").
       ival=iany([D_XCENTERED,D_YCENTERED])
       val=char(ival)
       call textjustify(val)
<br />
</pre>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_textjustify
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   use iso_c_binding
   implicit none
   real :: x1=-20.0, x2=20.0, y1=-20.0, y2=20.0
      call prefsize(int(x2-x1)*30,int(y2-y1)*30)
      !!call voutput('|ppmtogif &gt;images/textjustify.gif')
      !!call vinit('p6')
      call vinit(' ')
      call page(x1,x2,y1,y2)
      call clear()
      call textsize(0.9, 1.4)
      call font("times.rb")
      call linewidth(20)
      call seejustify( "right|top",           iany([d_right,d_top]),           -10.0, -10.0 )
      call seejustify( "right|ycentered",     iany([d_right,d_ycentered]),     -10.0,   0.0 )
      call seejustify( "right|bottom",        iany([d_right,d_bottom]),        -10.0, +10.0 )
      call seejustify( "xcentered|top",       iany([d_xcentered,d_top]),         0.0, -10.0 )
      call seejustify( "xcentered|ycentered", iany([d_xcentered,d_ycentered]),   0.0,   0.0 )
      call seejustify( "xcentered|bottom",    iany([d_xcentered,d_bottom]),      0.0, +10.0 )
      call seejustify( "left|top",            iany([d_left,d_top]),            +10.0, -10.0 )
      call seejustify( "left|ycentered",      iany([d_left,d_ycentered]),      +10.0,   0.0 )
      call seejustify( "left|bottom",         iany([d_left,d_bottom]),         +10.0, +10.0 )
      call vexit()
   contains
      subroutine seejustify(string,justify,x,y)
         implicit none
         real                    :: x, y
         real                    :: height, width
         integer(kind=c_short)   :: justify
         character(len=*)        :: string
         character(kind=c_char)  :: byte
         call color(D_RED)
         call move2(x-1.0,y); call draw2(x+1.0,y); call move2(x,y-1.0); call draw2(x,y+1.0)
         call circle(x,y,5.0)
         call color(D_BLUE)
         call move2(x,y)
         byte=char(justify)
         call textjustify(byte)
         call drawstr(string)
         call color(D_WHITE)
         call rmove2(-strlength(string),0.0)
         call rdraw2(+strlength(string),0.0)
         call getfontsize(width, height)
         call rmove2(0.0,height)
         call rmove2(-strlength(string),0.0)
         call rdraw2(+strlength(string),0.0)
      end subroutine seejustify
   end program demo_textjustify
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c385"><img src="../images/textjustify.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c388">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>textsize(3f)</b> - [M_draw:TEXT] Set text size of a character in the current SOFTWARE font in world units. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>textsize</b>(<i>width</i>, <i>height</i>)
<b>real,intent</b>(<i>in</i>) :: <i>width</i>
<b>real,intent</b>(<i>in</i>) :: <i>height</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set the maximum size of a character <i>in</i> the current font. Width and <i>height</i> are values <i>in</i> world units. This applies to
        software text, but may not apply to hardware fonts depending upon the output device. This must be done after the font being scaled is loaded. To
        keep text of different sizes aligned along the same baseline not that you typically need to subtract the descender <i>height</i> from the Y
        position</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_textsize
   use M_draw
   implicit none
   integer :: i,ii
   integer :: ipaws
      !! set up long bar as plotting area
      call prefsize(900,150)
      call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
      call ortho2(-30.0, 30.0, -5.0, 5.0)
      call font('times.r')
<br />      call move2(-23.0,-4.5)
      call color(D_WHITE)
      call textsize(2.0,2.0)
      call move2(-27.5,-3.0)
      call draw2( 27.5,-3.0)
      call move2(-27.5,-3.0)
<br />      do i=1,7
         ii=nint((i*20)*0.30)
         call linewidth(nint(ii*2.35))
         call textsize(real(i),real(i))
         call color(D_MAGENTA)
         call drawstr('aA')
      enddo
<br />      ipaws=getkey()
<br />      call vexit()
<br />   end program demo_textsize
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c388"><img src="../images/textsize.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c391">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>textslant(3f)</b> - [M_draw:TEXT] Defines the obliqueness of the fonts. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>textslant</b>(<i>var</i>)
real <i>var</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Defines the obliqueness of the fonts. This is a simplistic method that allows you to generate italicized versions of the software fonts. The x-
        values of the software font coordinates after the current <b>textsize</b>() values are applied are multiplied by (1+val).</p>
        <p>Note that this means the same value tilts the characters less the taller the characters are relative to their width.</p>
        <p>Generally, practical values are generally between <b>-1</b> and 1 times the</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_textslant
   use M_draw
   implicit none
   real    :: x1, x2, y1, y2
   real    :: scl
   integer :: key
      call prefsize(1200,300)
      call vinit(' ')
      call color(D_BLACK)
      call clear()
      x1=0.0; x2=40.0; y1=0.0; y2=10.0; scl=3*0.7
      call page(x1,x2,y1,y2)
      call font("times.rb")
      call linewidth(180)
      call textsize(0.8*scl,1.2*scl)
      call move2( x1+.3,y1+.4)
      call color(D_RED); call textslant(0.0);  call drawstr("textslant(0.0); ")
      call color(D_GREEN); call textslant(-1.0); call drawstr(" textslant(-1.0);")
      call color(D_BLUE); call textslant(1.0);  call drawstr(" textslant(1.0);")
      call textsize(0.8*scl,1.2*3*scl)
      call move2(x1+.3,y1+3+.4)
      call color(D_MAGENTA); call textslant(1.0); call drawstr(" textslant(1.0);")
      call textsize(0.8*scl,1.2*scl)
      call color(D_CYAN); call textslant(0.3); call drawstr(" textslant(0.3);")
      call color(D_WHITE); call textslant(0.5); call drawstr(" textslant(0.5);")
      call vflush()
      key=getkey()
      call vexit()
   end program demo_textslant
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c391"><img src="../images/textslant.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c394">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>textweight(3f)</b> - [M_draw:TEXT] Defines the weight of the fonts. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>textweight</b>(<i>ival</i>)
integer <i>ival</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Defines the weight of the fonts. Currently, the predefined constants in C and Fortran are D_NORMAL and D_BOLD; which correspond to 0 and</p>
        <table cellpadding="3">
          <!-- tsb: Defines the weight of the fonts. Currently, the predefined constants
 -->
          <tr valign="top">
            <td width="4%">1.</td>
            <td>This is not the same as using linethickess to change the appearance of a software font. The font is redrawn multiple times with a slight
            offset to create the bold appearance.</td>
          </tr>
        </table>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_textweight
   use M_draw
   implicit none
   real,parameter :: w=40.0
   integer        :: key
      call prefsize(600,600)
      call vinit(' ')
      call color(D_BLACK)
      call clear()
      call color(D_YELLOW)
      call page(-w,w,-w,w)
      call font("times.rb")
      call linewidth(180)
      call textsize(15.0,15.0)
      call centertext(.true.)
      call linewidth(0);call color(D_BLUE)
      call move2(0.0, W/2.0)
<br />      call textweight(0)
      call drawstr('NORMAL')
<br />      call linewidth(0);call color(D_MAGENTA)
      call move2(0.0, 0.0-W/2.0)
<br />      call textweight(1)
      call drawstr('BOLD')
<br />      call vflush()
      key=getkey()
      call vexit()
   end program demo_textweight
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c394"><img src="../images/textweight.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c397">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>topjustify(3f)</b> - [M_draw:TEXT] top justify text <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>topjustify</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Top justifies text. The text string will be drawn with its upper edge aligned with the current Y position. Bottom justification and Y centering are
        turned off.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_topjustify
   use M_draw
   implicit none
   real    :: x1, x2, y1, y2
   real    :: scl, ax, bx
   integer :: key
      call prefsize(1200,120)
      call vinit(' ')
      x1=0; x2=40; y1=0; y2=4; scl=1.9
      call page(x1,x2,y1,y2)
      call textsize(0.9*scl,1.4*scl)
      call font("times.rb")
      call linewidth(200)
      AX=(x1+x2)/2+0.3; BX=y1+3.3
      call move2(AX,BX)
      call topjustify()
      call color(D_BLUE)
      call drawstr("topjustify()")
      call color(D_RED)
      call move2(AX-1.0,BX)
      call draw2(AX+1.0,BX)
      call move2(AX,BX-1.0)
      call draw2(AX,BX+1.0)
      call vflush()
      key=getkey()
      call vexit()
   end program demo_topjustify
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c397"><img src="../images/topjustify.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c400">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>translate(3f)</b> - [M_draw:TRANSFORMATION] Set up a translation. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>translate</b>(<i>x</i>, <i>y</i>, <i>z</i>)
real <i>x</i>, <i>y</i>, <i>z</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Set up a translation.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_translate
   !
   !      a demonstration of objects
   !
   use M_draw
<br />   integer SPHERE
   real RADIUS
   parameter (RADIUS = 10.0)
   parameter(SPHERE = 1)
   character(len=50) :: device
   integer           :: ios
<br />   print*,'Enter output device:'
   read(*,'(a)',iostat=ios) device
   if(ios.ne.0)device=' '
<br />   call vinit(device)
<br />   call vsetflush(.false.)
   !
   ! set up our viewing transformation
   !
   call perspective(90.0, 1.0, 0.001, 500.0)
   call lookat(13.0, 13.0, 8.0, 0.0, 0.0, 0.0, 0.0)
<br />   call color(D_BLACK)
   call clear()
   !
   ! Call a routine to make the sphere object
   !
   call makesphere()
<br />   !
   ! Now draw the sphere object scaled down. We use the pushmatrix
   ! and the popmatrix to preserve the transformation matrix so
   ! that only this sphere is drawn scaled. The callobj then enables
   ! us to draw the sphere we generated with makeobj in makesphere.
   !
   call color(D_CYAN)
<br />   call pushmatrix()
   call scale(0.5, 0.5, 0.5)
   call callobj(SPHERE)
   call popmatrix()
   !
   ! now we draw the same sphere translated, with a different
   ! scale and color.
   !
   call color(D_WHITE)
<br />   call pushmatrix()
   call translate(0.0, (-1.4) * RADIUS, 1.4 * RADIUS)
   call scale(0.3, 0.3, 0.3)
   call callobj(SPHERE)
   call popmatrix()
   !
   ! and maybe a few more times....
   !
   call color(D_RED)
<br />   call pushmatrix()
   call translate(0.0, RADIUS, 0.7 * RADIUS)
   call scale(0.2, 0.2, 0.2)
   call callobj(SPHERE)
   call popmatrix()
<br />   call color(D_GREEN)
<br />   call pushmatrix()
   call translate(0.0, 1.5 * RADIUS, -RADIUS)
   call scale(0.15, 0.15, 0.15)
   call callobj(SPHERE)
   call popmatrix()
<br />   call color(D_YELLOW)
<br />   call pushmatrix()
   call translate(0.0, -RADIUS, -RADIUS)
   call scale(0.12, 0.12, 0.12)
   call callobj(SPHERE)
   call popmatrix()
<br />   call color(D_BLUE)
<br />   call pushmatrix()
   call translate(0.0, (-2.0)*RADIUS, -RADIUS)
   call scale(0.3, 0.3, 0.3)
   call callobj(SPHERE)
   call popmatrix()
<br />   idum=getkey()
<br />   call vexit()
   contains
   subroutine makesphere
   !
   !        make a sphere object
   !
   integer SPHERE
   integer ii
   real i, r, z, a, RADIUS, PI
   parameter (PI = 3.1415926535, RADIUS = 10.0, SPHERE = 1)
<br />   call makeobj(SPHERE)
   !
   ! create the latitudinal rings
   !
   do ii = 0, 180, 20
      call pushmatrix()
      i=real(ii)
      call rotate(i, 'y')
      call circle(0.0, 0.0, RADIUS)
      call popmatrix()
   enddo
   !
   ! create the longitudinal rings
   !
   call pushmatrix()
   call rotate(90.0, 'x')
   do ia = -90, 90, 20
      a=ia
      r = RADIUS * cos(a * PI / 180.0)
      z = RADIUS * sin(a * PI / 180.0)
      call pushmatrix()
      call translate(0.0, 0.0, -z)
      call circle(0.0, 0.0, r)
      call popmatrix()
   enddo
   call popmatrix()
<br />   call closeobj()
<br />   end subroutine makesphere
<br />   end program demo_translate
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c400"><img src="../images/translate.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c410">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>unexpandviewport(3f)</b> - [M_draw:VIEWPORT] undo <b>expandviewport</b>(3f) <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>unexpandviewport</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Does the reverse of expandviewport. Basically, it returns M_draw to using the largest square of the device for its viewport calculations.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_unexpandviewport
   use M_draw
   use M_draw,    only  : D_BLACK,   D_WHITE
   use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
   use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
   implicit none
   integer :: ipaws
<br />   !! set up graphics area
   call prefsize(1000,200)
   call vinit(' ') ! start graphics using device $M_DRAW_DEVICEDEVICE
<br />   !! draw circle that fills default world coordinate window
   call polyfill(.true.)
   call color(D_GREEN)
   call circle(0.0,0.0,1.0)
   ipaws=getkey() !! pause
<br />   !! set new scales for viewport so &lt;-1,-1&gt; and &lt;1,1&gt; are at
   !! corners of display instead of corners of largest square
   !! that can fit on display
   call expandviewport()
   call viewport(-1.0,1.0,-1.0,1.0)
<br />   !! draw circle that fills default world coordinate window again
   !! instead of a circle, the mapping now produces an ellipse unless
   !! this device has a square display
   call polyhatch(.true.)
   call hatchpitch(0.1)
   call hatchang(30.0)
   call linewidth(40)
   call color(D_CYAN)
   call circle(0.0,0.0,1.0)
   ipaws=getkey() !! pause
<br />   !! set new scales for viewport so &lt;-1,-1&gt; and &lt;1,1&gt; are at
   !! corners of largest square that fits on display
   call unexpandviewport()
   !! actually change to the new viewport
   call viewport(-1.0,1.0,-1.0,1.0)
<br />   !! now the same circle should draw where the original one did
   call color(D_BLACK)
   call hatchang(120.0)
   call linewidth(40)
   call circle(0.0,0.0,1.0)
   ipaws=getkey() !! pause
<br />   call vexit()                  !! wrap up graphics
<br />   end program demo_unexpandviewport
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c410"><img src="../images/unexpandviewport.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c413">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>up(3f)</b> - [M_draw:VIEWPORT] Specify the world up. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>up</b>(<i>x</i>, <i>y</i>, <i>z</i>)
real <i>x</i>, <i>y</i>, <i>z</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Specify the world up. This can be used to prevent lookat's sometimes annoying habit of turning everything upside down due to the line of sight
        crossing the appropriate axis.
      </blockquote>
      <hr />
      <br />
      <div class="c413"><img src="../images/up.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c416">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>vexit(3f)</b> - [M_draw:DEVICE] Reset window/terminal and exit graphics mode. Must be last routine called. <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>vexit</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Reset the window/terminal and terminate graphics mode. Required to properly close out most output devices. Must be called before any second call
        to <b>vinit</b>(3f). Must be the last M_draw routine called.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
     program demo_vexit
     use M_draw, only: vinit, vexit, voutput, circle, linewidth, color
     use M_draw,    only  : D_BLACK,   D_WHITE
     use M_draw,    only  : D_RED,     D_GREEN,    D_BLUE
     use M_draw,    only  : D_YELLOW,  D_MAGENTA,  D_CYAN
     implicit none
     integer :: i
<br />     ! assuming you have the NetPBM package installed
     ! set up output to create a GIF file called one.gif
     call voutput('|ppmtogif &gt;vexit.gif')
<br />     call vinit('p6') ! start graphics
     ! default window is -1 &lt;= x &lt;= 1, -1 &lt;= y &lt;= 1
     ! default viewport is left bottom justified square
     ! so essentially you have a square drawing surface
     ! with the point &lt;0,0&gt; at the center of the square
     ! with X and Y ranging from -1 to 1.
<br />     call color(D_RED)
     call linewidth(100)
     ! this loop draws outside the current window
     ! but by default clipping is on
     do i=1,30
        call circle((real(i)-1)*0.04,0.0,1.0/real(i))
     enddo
<br />     call vexit() ! exited graphics so can start again
<br />     ! start second graphics session with new output
     ! device and output file
     call voutput('|ppmtogif &gt;vexit2.gif')
     call vinit('p6')
<br />     do i=10,1,-1
        call color(i)
        call circle(0.0,0.0,1.0/real(i))
     enddo
<br />     call vexit()
<br />     end program demo_vexit
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c416"><img src="../images/vexit.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c419">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>vflush(3f)</b> - [M_draw:FLUSHING] Call device flush or syncronisation routine <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>vflush</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Call the device flush or syncronisation routine. This forces a flush.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c419"><img src="../images/vflush.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c422">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>vgetdev(3f)</b> - [M_draw:DEVICE] Get name of current device <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>vgetdev</b>(<i>device</i>)
character *(*) <i>device</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Gets the name of the current M_draw <i>device</i>. The C version of the routine also returns a pointer to its argument.</p>
      </blockquote>
      <hr />
      <br />
      <div class="c422"><img src="../images/vgetdev.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c425">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>viewport(3f)</b> - [M_draw:VIEWPORT] Specify which part of screen to draw in <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>viewport</b>(<i>left</i>, <i>right</i>, <i>bottom</i>, <i>top</i>)
<b>real,intent</b>(<i>in</i>) :: <i>left</i>, <i>right</i>, <i>bottom</i>, <i>top</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Specify which part of the screen to draw <i>in</i>. Left, <i>right</i>, <i>bottom</i>, and <i>top</i> are real values <i>in</i> screen coordinates
        (0:n,0:m).
        <p>If a device has been declared to be 600 x 400</p>
        <pre>
        o-----&gt; X                         (right=600,top=0)
        | #------------------------------------#
        | |                                    |
        | |                                    |
        V |                                    |
        Y |                                    |
          #------------------------------------#
</pre>(<i>left</i>=0,<i>bottom</i>=400)
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_viewport
   !
   ! using non-square viewports, the associated distortion -- and how to fix it
   !
   use M_draw
<br />   character(len=50)  :: device
   character(len=120) :: buf
   real    xfact, yfact
   integer :: ios
<br />   print*,'Enter output device:'
   read(*,'(a)',iostat=ios)device
   if(ios.ne.0)device=' '
<br />   call vinit(device)
<br />   call color(D_BLACK)
   call clear()
   !
   ! Make the viewport the same size as the screen/window.
   !
   call getfactors(xfact, yfact)
   call viewport(-1.0, xfact, -1.0, yfact)
   !
   ! Draw a square. (Looks like a rectangle, if the viewport
   ! wasn't "accidentally" square)
   !
   call color(D_RED)
   call rect(-0.5, -0.5, 0.5, 0.5)
   !
   ! Tell them what it is.
   !
   call move2(-1.0, 0.9)
   write(buf,'(''Distorted square (viewport(-1, '', F7.3, '', -1, '', F7.3, ''))'')') xfact, yfact
   call drawstr(buf)
<br />   idum=getkey()
   !
   ! Fix up the distortion (The actual formula to fix
   ! the distortion is (viewport.xmax * (1 + xfact) / 2.0),
   ! and similar for the y axis.
   !
   call ortho2(-1.0, xfact, -1.0, yfact)
   !
   ! Draw another square (Really is square this time)
   !
   call color(D_YELLOW)
   call rect(-0.5, -0.5, 0.5, 0.5)
   !
   ! Tell them what it is.
   !
   call move2(-1.0, -0.9)
   write(buf,'(''Fixed up square with ortho2(-1, '', F7.3, '', -1, '', F7.3, '')'')') xfact, yfact
   call drawstr(buf)
<br />   idum=getkey()
   !
   ! Do it with world coords going from 0 - 5, 0 - 5.
   ! Reset square viewport.
   !
   call color(D_BLACK)
   call clear()
<br />   call viewport(-1.0, 1.0, -1.0, 1.0)
   call ortho2(0.0, 5.0, 0.0, 5.0)
   call textsize(0.1, 0.1)
   !
   ! Square from 1 to 3. (Really is square)
   !
   call color(D_GREEN)
   call rect(1.0, 1.0, 3.0, 3.0)
<br />   call move2(0.0, 4.5)
   call drawstr('Square from 0 - 3, 0 - 3')
<br />   idum=getkey()
   !
   ! Distort it with a non-square viewport.
   !
   call viewport(-1.0, xfact, -1.0, yfact)
<br />   call color(D_BLUE)
   call rect(1.0, 1.0, 3.0, 3.0)
<br />   call move2(0.0, 0.5)
   call drawstr('Distorted square from 0 - 3, 0 - 3')
<br />   idum=getkey()
   !
   ! Fix the distortion.
   !
   call ortho2(0.0, 5.0 * (1.0 + xfact) / 2.0, 0.0, 5.0 * (1.0 + yfact) / 2.0)
<br />   call color(D_MAGENTA)
   call rect(1.0, 1.0, 3.0, 3.0)
<br />   call move2(0.0, 2.5)
   call drawstr('Fixed up  square from 0 - 3, 0 - 3')
<br />   idum=getkey()
<br />   call vexit()
<br />   end program demo_viewport
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c425"><img src="../images/viewport.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c428">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>vinit(3f)</b> - [M_draw:DEVICE] Initialise device <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="5">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>vinit</b>(<i>device</i>)
<b>character</b>(len=*),intent(<i>in</i>) :: <i>device</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Initialise the <i>device</i>.
      </blockquote>
      <blockquote>
        Note 1 : Currently available devices are:
      </blockquote><a name=""></a>
      <h4><a name="">INTERACTIVE DEVICES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">PC</td>
            <td valign="bottom">- native MSW PC driver; only tested from CygWin</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">X11</td>
            <td valign="bottom">- X11 windows (Black background)</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">x11</td>
            <td valign="bottom">- X11 windows (White background)</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">tek</td>
            <td valign="bottom">- tektronix 4010 and compatibles xtek - X11 xterm Tektronix 4010 emulator</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">PRINTERS AND PLOTTERS</a></h4>
      <blockquote>
        <p>PostScript: [p]psm or [p]postscript - monochrome PostScript [p]psg - grayscale PostScript [p]psc - color PostScript HPGL: hpgl - HP Graphics
        language and compatibles [p]hpgl2 - HPGL level 2 (obeys prefsize calls) PCL:</p>
        <blockquote>
          <table cellpadding="3">
            <!-- tsb: PostScript:
 -->
            <tr valign="top">
              <td class="c429" colspan="1">[p]pclland</td>
              <td>- monochrome PCL5 (obeys prefsize calls)</td>
            </tr>
            <tr valign="top">
              <td class="c429" colspan="1">[p]pclport</td>
              <td>- monochrome PCL5 (obeys prefsize calls) pcl5land (color PCL5 landscape) pcl5port (color PCL5 portrait)</td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>PIXMAPS (COLOR) AND BITMAPS (MONOCHROME)</p>
      <blockquote>
        <table cellpadding="3">
          <!-- tsb: PIXMAPS (COLOR) AND BITMAPS (MONOCHROME)
 -->
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">char</td>
            <td valign="bottom">An ASCII file that can be displayed to most <b>xterm</b>(1) terminal emulators that support color</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">p1/pbm</td>
            <td valign="bottom">Poskanzer (pbmplus/netplus) portable ASCII bitmap file</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">p3/ppm</td>
            <td valign="bottom">Poskanzer portable ASCII pixmap file</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">p4</td>
            <td valign="bottom">Poskanzer portable binary bitmap file</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">p6</td>
            <td valign="bottom">Poskanzer portable binary pixmap file</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">xbm</td>
            <td valign="bottom">X11 bitmap file</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">bm</td>
            <td valign="bottom">bitmap format for <b>atobm</b>(1)</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">PRODUCT INPUT FILES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">mif</td>
            <td valign="bottom">FrameMaker Interchange Format 3.0 (MIF) files (16 colors)</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">mif4</td>
            <td valign="bottom">FrameMaker Interchange Format 4.0 (MIF) files (user-definable colors, but breaks a MIF rule)</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">xfig</td>
            <td valign="bottom">X11 <b>xfig</b>(1) figure utility</td>
          </tr>
          <tr>
            <td colspan="2">METAFILES WITH POST_PROCESSORS/CONVERTERS</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">cgmt</td>
            <td valign="bottom">a clear-text CGM (Computer Graphics Metafile)</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">gnu</td>
            <td valign="bottom">GNU <b>plot</b>(1) metafile</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">pdf</td>
            <td valign="bottom">Adobe Public Document Format</td>
          </tr>
          <tr valign="top">
            <td class="c429" colspan="2">unixplot</td>
          </tr>
          <tr valign="top">
            <td width="6%"></td>
            <td>Unix <b>plot</b>(1) metafile</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">BROWSER FILES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">canvas</td>
            <td valign="bottom">HTML5 CANVAS graphics element file</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">svg</td>
            <td valign="bottom">Scalable Vector Graphics</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">usemap</td>
            <td valign="bottom">HTML image map</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">vml</td>
            <td valign="bottom">Microsoft Vector Markup Language</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">FILES</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">vog</td>
            <td valign="bottom">M_draw low level call record (debug)</td>
          </tr>
        </table>
      </blockquote><a name=""></a>
      <h4><a name="">OTHER</a></h4>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">fti</td>
            <td valign="bottom">SGI vector-based icons</td>
          </tr>
          <tr valign="top">
            <td class="c429" width="6%" nowrap="nowrap">null</td>
            <td valign="bottom">no output</td>
          </tr>
        </table>
      </blockquote>
      <p>:- Drivers I've dropped but code is there for ---------------------------------------------</p>
      <pre>
       grwin - (minGW GRwin PC interface)
       decX11 - the decstation window manager
       dxy - roland DXY plotter language
       sun - Sun workstations running sunview
       next - NeXTStep and other NeXT platforms
       apollo - Apollo workstations
<br />
</pre>
      <blockquote>
        :- Drivers I've dropped but are <i>in</i> the original distribution ------------------------------------------------------------
        <pre>
       hercules - IBM PC hercules graphics card
       cga - IBM PC cga graphics card
       ega - IBM PC ega graphics card
       vga - IBM PC vga graphics card
       sigma - IBM PC sigma graphics card.
       mswin - IBM PC Microsoft Windows.
<br />
</pre>
      </blockquote>Note 2 : If <i>device</i> is a NULL or a null string the value of the environment variable "M_DRAW_DEVICE" is taken as the <i>device</i>
      type to be opened. The format of the variable is
      <pre>
            M_DRAW_DEVICE [ xsize [ ysize [ xoffset [ yoffset ] ] ]
<br />
</pre>
      <blockquote>
        That is, if present xsize and ysize will be used <i>in</i> a call to <b>prefsize</b>(3c), and xoffset and yoffset will be used <i>in</i> a call to
        <b>preposition</b>(3c).
      </blockquote>
      <p>Note 3 : after <b>vinit</b>() it is wise to explicitly clear the screen. e.g.:</p>
      <pre>
         call color(D_BLACK)
         call clear()
<br />
</pre><a name="3"></a>
      <h3><a name="3">NOTES</a></h3>
      <blockquote>
        <p>gnu</p>
        <pre>
   The GNU plotutils package includes a program called plot(1) that
   can read in the gnu metafile and render images on an X11 display, PNG
   (Portable Network Graphics) format, portable anymap format (PBM/PGM/PPM),
   a pseudo-GIF format that does not use LZW encoding, the new XML-based
   Scalable Vector Graphics format, the format used by Adobe Illustrator,
   Postscript or Encapsulated Postscript (EPS) that can be edited with
   idraw(1), CGM format (by default, confirming to the WebCGM profile),
   the format used by the xfig(1) drawing editor, the Hewlett-Packard PCL 5
   printer language, the Hewlett-Packard Graphics Language, ReGIS graphics
   format (which can be displayed by the dxterm(1) terminal emulator or
   by a VT330 or VT340 terminal), Tektronix format (which can be displayed
   by the xterm(1) terminal emulator), and device-independent GNU metafile
   format itself.
<br />
</pre>pdf
        <pre>
   Popular PDF readers are the Adobe PDF viewer, which is often callable from
   Web browsers; the GhostScript-based gv(1) utility; or the xpdf program.
<br />       The xpdf(1) software , related utilities ( pdftops(1), pdftotext(1),
       pdfinfo(1), pdffonts(1), pdftoppm(1), pdfimages(1), xpdfrc (5))
       and documentation are copyright 1996-2004 Glyph &amp; Cog, LLC. at
       <a href="http://www.foolabs.com/xpdf">http://www.foolabs.com/xpdf</a>/
<br />
</pre>
        <blockquote>
          The GhostScript-based tools can convert PDF files to PostScript as well as view the files.
        </blockquote>
        <p>cgmt</p>
        <pre>
   The ralcgm(1) and gplot(1) packages are two very complete CGM viewers.
<br />   ppm,pbm (and p1,p3,p4,p6)
<br />     * p1/pbm - Poskanzer (pbmplus/netplus) portable ASCII bitmap file
     * p3/ppm - Poskanzer portable ASCII pixmap file
     * p4 - Poskanzer portable binary bitmap file
     * p6 - Poskanzer portable binary pixmap file
<br />   The NetPBM package is available for almost every platform and lets
   you convert the Poskanzer portable pixmap (PPM) files to just about
   any pixmap or bitmap format, including PNG, JPEG, GIF/PseudoGIF, BPM,
   ..... Other popular pixmap products such as ImageMagick, gv, ... can
   read PPM files, convert them, and often edit them.
<br />
</pre>HTML:
        <pre>
   The vml, canvas, svg, and usemap drivers are primarily used to generate
   graphics for inclusion in HTML documents. Browsers such as Opera, Safari,
   Foxfire, and Chrome can easily incorporate graphics generated using the
   SVG (Scalable Vector Graphics) format or the HTML5 CANVAS element.
<br />
</pre>usemap
        <pre>
   This driver writes out the edges of any polygon in a format that can be
   used with an HTML image map; if the same sizes are used a plot generated
   with the ppm driver; you will have clickable regions in your pixmap when
   converted to a GIF image.
<br />   If the polygons overlap you need to reverse the order of the polygon
   definitions in the output file. The numeric field in the&lt;AREA&gt; titles
   should help.
<br />
</pre>vml
        <pre>
   The VML format can be read in by any MicroSoft Office 2000+ product and
   MicroSoft's web browser Internet Explorer. If the plots contain more than
   about 9766 vectors MicroSoft Word starts choking (still true in 2005),
   but otherwise this is a very nice way to generate input for MicroSoft
   products.
<br />   I generally use this on a machine running MicroSoft Windows by installing
   CygWin with the X11 options (and ralcgm, the GhostScript software,
   the GNU plotutils packages and netpbm).
<br />
</pre>xfig
        <pre>
   The xfig(1) command can be used to edit graphics generated with the
   M_draw graphics library; and to convert the xfig(1)-format file to
   many other output formats. If you are generating pixmaps with the PPM
   driver and want to use them as image maps in your HTML documents the
   usemap driver can be used.
<br />   If you have xfig(1) installed, you will find that calling fig2dev(1)
   allows you to generate many output formats from a single file,
   including LaTex and encapsulated PostScript.
<br />   xfig(1) is an X11 Windows application that can be used to interactively
   edit figures. The HELP utility of xfig(1) provides a description of the
   xfig(1) file format (as well as a user guide and many other documents).
<br />   Unfortunately, the manual indicates the user defined colors must
   be defined before any other Fig objects. By default, 16 colors are
   defined. If undefined colors are used they are assigned a dash pattern
   or a fill pattern to help distinguish them. Use of hardware dash and
   M_draw software dash could get confusing.
<br />   Also, in the current driver version all lines are drawn as a series
   of move-draw vectors, which can make the files relatively very large.
<br />   multiple pages appear to only work with the PostScript and PDF drivers
   of xfig(1); and even then pages must be all positive numbers from left
   to right and top to bottom, printing all pages in a rectangular area.
<br />   Alternatively, could use depth to keep up to 999 pages separate
<br />
</pre>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
      program demo_vinit
      use M_draw
      use ISO_C_BINDING
      integer :: ios
      character(len=50) :: device
<br />      ! read in device name and start graphics mode
      print*,'Enter output device:'
      read(*,'(a)',iostat=ios)device
      if(ios.ne.0)device=' '
      call vinit(device)
      ! by default the drawing surface is
      ! a square ranging from -1 to 1 in both
      ! the X and Y axis
<br />      ! set font to large hardware font
      call font('large')
<br />      ! set current color to black
      call color(D_BLACK)
<br />      ! clear to current color
      call clear()
<br />      ! we want to draw in green
      call color(D_GREEN)
<br />      ! draw a horizontal line at y = 0
      call move2(-1.0, 0.0)
      call draw2(1.0, 0.0)
<br />      ! pause for some input
      idum=getkey()
<br />      ! draw a line along x = 0
      call move2(0.0, 0.0)
      call draw2(0.0, 1.0)
<br />      ! move to the middle of the screen
      call move2(0.0, 0.0)
<br />      ! draw 'Hello' starting at the origin
      call drawstr('Hello')
<br />      ! pause again
      idum=getkey()
<br />      !  wrap up and exit graphics mode
      call vexit()
<br />      end program demo_vinit
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c428"><img src="../images/vinit.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c432">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>vnewdev(3f)</b> - [M_draw:DEVICE] Reinitialize to use new device without changing <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>vnewdev</b>(<i>device</i>)
character *(*) <i>device</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Reinitialize M_draw to use a new <i>device</i> without changing attributes, viewport etc. (eg. window and viewport specifications)</p>
      </blockquote>
      <hr />
      <br />
      <div class="c432"><img src="../images/vnewdev.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c435">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>voutput(3f)</b> - [M_draw:DEVICE] Redirect output from *next* vinit to file <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>voutput</b>(<i>path</i>)
character*(*) <i>path</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Redirect output from *next* <b>vinit</b>() to file given by <i>path</i>. This routine only applies to device drivers that write to stdout e.g.
        PostScript and hpgl.</p>
        <p>The special file names are</p>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td width="3%">-</td>
              <td>is standard output</td>
            </tr>
            <tr valign="top">
              <td width="3%">+</td>
              <td>is standard error</td>
            </tr>
            <tr valign="top">
              <td width="3%">|</td>
              <td> command will create a pipe to "command"</td>
            </tr>
          </table>
        </blockquote>
        <p>If the open of the file fails, an attempt is made to append to file "M_DRAW_OUTPUT". If this fails, standard output is used.</p>
        <p>When <b>vinit</b>() is called if <b>voutput</b>() has not been called then the environment variable M_DRAW_OUTPUT is checked and if it is defined
        and not a null string then <b>voutput</b>() is called with the M_DRAW_OUTPUT variable's value.</p>
        <p>A common use of the |command option is to automatically call programs that convert PPM files to other common pixmap formats or converts the GNU
        metafile to other formats (typically via the GNU plotutils plot program).</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_voutput
   use M_draw
   implicit none
   ! want a 400x400 raster output
   call prefsize(400,400)
   ! convert PPM to a GIF file using ppmtogif(1)
   call voutput('|ppmtogif &gt;voutput.gif')
   ! start graphics using PPM device
   call vinit('p6')
   ! draw a filled circle
   call color(D_RED)
   call polyfill(.true.)
   call circle(0.0,0.0,1.0)
   !
   call vexit()
   end program demo_voutput
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c435"><img src="../images/voutput.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c438">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>vsetflush(3f)</b> - [M_draw:FLUSHING] Set global flushing status <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="3">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>vsetflush</b>(<i>yesno</i>)
logical <i>yesno</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set global flushing status. If <i>yesno</i> = 0 (.false.) then don't do any flushing (except in <b>swapbuffers</b>(), or <b>vflush</b>()). If
        <i>yesno</i> = 1 (.true.) then do the flushing as described above.
      </blockquote>
      <hr />
      <br />
      <div class="c438"><img src="../images/vsetflush.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c441">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>window(3f)</b> - [M_draw:PROJECTION] Specify a perspective viewing pyramid <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>window</b>(<i>left</i>, <i>right</i>, <i>bot</i>, <i>top</i>, <i>near</i>, <i>far</i>)
real <i>left</i>, <i>right</i>, <i>bot</i>, <i>top</i>, <i>near</i>, <i>far</i>
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Specify a perspective viewing pyramid in world coordinates by giving the rectangle closest to the eye (ie. at the <i>near</i> clipping plane) and
        the distances to the <i>near</i> and <i>far</i> clipping planes.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_windows
   use M_draw
   integer CUBE, TOPLEFT, TOPRIGHT, BOTTOMLEFT, BOTTOMRIGHT
   parameter(CUBE = 1, TOPLEFT = 2, TOPRIGHT = 3, BOTTOMLEFT = 4, BOTTOMRIGHT = 5)
   character(len=20) :: device
   print*,'Enter device name:'
   read(*,'(A)',iostat=ios)device
   if(ios.ne.0)device=' '
   call vinit(device)
   call pushviewport
   call textsize(0.5, 0.9)
   call font('futura.m')
   call color(D_BLACK)
   call clear
   ! make an object that represents the cube
   call makecube
   ! set up an object which draws in the top left of the screen.
   call makeobj(TOPLEFT)
   call viewport(-1.0, 0.0, 0.0, 1.0)
   call ortho2(-5.0, 5.0, -5.0, 5.0)
   call color(D_RED)
   call rect(-5.0, -5.0, 5.0, 5.0)
   call perspective(40.0, 1.0, 0.1, 1000.0)
   call lookat(5.0, 8.0, 5.0, 0.0, 0.0, 0.0, 0.0)
   ! Call an object within another object
   call callobj(CUBE)
   call color(D_GREEN)
   call move2(-4.5, -4.5)
   call drawstr('perspective/lookat')
   call closeobj
   ! now set up one which draws in the top right of the screen
   call makeobj(TOPRIGHT)
   call viewport(0.0, 1.0, 0.0, 1.0)
   call ortho2(-5.0, 5.0, -5.0, 5.0)
   call color(D_GREEN)
   call rect(-5.0, -5.0, 5.0, 5.0)
   call window(-5.0, 5.0, -5.0, 5.0, -5.0, 5.0)
   call lookat(5.0, 8.0, 5.0, 0.0, 0.0, 0.0, 0.0)
   call callobj(CUBE)
   call color(D_RED)
   call move2(-4.5, -4.5)
   call drawstr('window/lookat')
   call closeobj
   ! try the bottom left
   call makeobj(BOTTOMLEFT)
   call viewport(-1.0, 0.0, -1.0, 0.0)
   call ortho2(-5.0, 5.0, -5.0, 5.0)
   call color(D_MAGENTA)
   call rect(-5.0, -5.0, 5.0, 5.0)
   call perspective(40.0, 1.0, 0.1, 1000.0)
   call polarview(15.0, 30.0, 30.0, 30.0)
   call callobj(CUBE)
   call color(D_YELLOW)
   call move2(-4.5, -4.5)
   call drawstr('perspective/polarview')
   call closeobj
   ! and the bottom right
   call makeobj(BOTTOMRIGHT)
   call viewport(0.0, 1.0, -1.0, 0.0)
   call ortho2(-5.0, 5.0, -5.0, 5.0)
   call color(D_CYAN)
   call rect(-5.0, -5.0, 5.0, 5.0)
   call window(-5.0, 5.0, -5.0, 5.0, -5.0, 5.0)
   call polarview(8.0, -18.0, -3.0, 18.0)
   call callobj(CUBE)
   call color(D_BLUE)
   call move2(-4.5, -4.5)
   call drawstr('window/polarview')
   call closeobj
   ! now draw them
   call callobj(TOPLEFT)
   call callobj(TOPRIGHT)
   call callobj(BOTTOMLEFT)
   call callobj(BOTTOMRIGHT)
   idum=getkey()
   call vexit
   !=====================================================================
   contains
   !=====================================================================
   subroutine makecube
   ! set up a cube
   integer CUBE
   parameter (CUBE = 1)
   call makeobj(CUBE)
   ! The border around the cube
   call rect(-5.0, -5.0, 10.0, 10.0)
   ! Make the cube from 4 squares
   call pushmatrix()
   call side()
   call rotate(90.0, 'x')
   call side()
   call rotate(90.0, 'x')
   call side()
   call rotate(90.0, 'x')
   call side()
   call popmatrix()
   call closeobj()
   end subroutine makecube
   !=====================================================================
   subroutine side
   ! define a face for the cube
   call pushmatrix
   call translate(0.0, 0.0, 1.0)
   call rect(-1.0, -1.0, 1.0, 1.0)
   call popmatrix
   end subroutine side
   !=====================================================================
   end program demo_windows
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c441"><img src="../images/window.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c444">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>xcentertext(3f)</b> - [M_draw:TEXT] set text centering mode on in X direction <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>xcentertext</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Set text centering mode on in X direction. Y justification is turned off.
        <p>Centers text in the X direction. The text string will begin at a point to the notional left of the current position and finish at a point to the
        right of the current position. Left justification and Right justification are turned off.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_xcentertext
   use M_draw
   implicit none
   real    :: x1, x2, y1, y2
   real    :: scl, ax, bx
   integer :: key
      call prefsize(1200,120)
      call vinit(' ')
      x1=0; x2=40; y1=0; y2=4; scl=1.9
      call page(x1,x2,y1,y2)
      call textsize(0.9*scl,1.4*scl)
      call font("times.rb")
      call linewidth(200)
      AX=(x1+x2)/2+4; BX=y1+1.3
      call move2(AX,BX)
      call xcentertext()
      call color(D_GREEN)
      call drawstr("xcentertext()")
      call color(D_RED)
      call move2(AX-1.0,BX)
      call draw2(AX+1.0,BX)
      call move2(AX,BX-1.0)
      call draw2(AX,BX+1.0)
      call vflush()
      key=getkey()
      call vexit()
   end program demo_xcentertext
<br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c444"><img src="../images/xcentertext.gif" /></div>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c447">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>ycentertext(3f)</b> - [M_draw:TEXT] center text in the Y direction <b></b>
      </blockquote><a name="contents" id="contents"></a>
      <h3><a name="4">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>ycentertext</b>()
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Centers text in the Y direction. The text string will so that its center line is aligned with the current y position. Top justification and Bottom
        justification are turned off.
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_ycentertext
   use M_draw
   implicit none
   real    :: x1, x2, y1, y2
   real    :: scl, ax, bx
   integer :: key
      call prefsize(1200,120)
      call vinit(' ')
      call color(D_BLACK)
      call clear()
      x1=0; x2=40; y1=0; y2=4; scl=1.9
      call page(x1,x2,y1,y2)
      call textsize(0.9*scl,1.4*scl)
      call font("times.rb")
      call linewidth(200)
      AX=(x1+x2)/2.0; BX=(y1+y2)/2.0
      call move2(AX,BX)
      call ycentertext()
      call color(D_MAGENTA)
      call drawstr("ycentertext()")
      call color(D_CYAN)
      call move2(AX-1.0,BX)
      call draw2(AX+1.0,BX)
      call move2(AX,BX-1.0)
      call draw2(AX,BX+1.0)
      call vflush()
      key=getkey()
      call vexit()
   end program demo_ycentertext
<br /><br />
</pre>
      </blockquote>
      <hr />
      <br />
      <div class="c447"><img src="../images/ycentertext.gif" /></div>
    </div>
  </div>
</div>
</article>
</body>
</html>
